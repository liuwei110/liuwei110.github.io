<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vera的主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-06T13:51:38.843Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Vera Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网之TCP</title>
    <link href="http://yoursite.com/2019/02/26/%E8%AE%A1%E7%BD%91%E4%B9%8BTCP/"/>
    <id>http://yoursite.com/2019/02/26/计网之TCP/</id>
    <published>2019-02-26T02:22:10.000Z</published>
    <updated>2019-03-06T13:51:38.843Z</updated>
    
    <content type="html"><![CDATA[<p>TCP<br><a id="more"></a></p><h1 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h1><p>TCP协议全称: 传输控制协议, 顾名思义, 就是要对数据的传输进行一定的控制. </p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>第一次：客户端发送SYN=1,seq=x给服务器，客户端进入SYN-SENT状态<br>第二次：服务器接收到请求进入到SYN-RCVD状态，并发送SYN=1,ACK=1,ack=x+1,seq=y给客户端<br>第三次：客户端发送ACK=1,ack=y+1,seq=x+1给服务器，并且客户端进入established状态，服务器接受到也进入established状态<br><strong>为什么需要三次握手？</strong><br>怕突然已经失效的连接请求突然到达服务器</p><h1 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h1><p>第一次：客户端发送FIN=1,seq=u给服务器，客户端进入FIN-WAIT1状态<br>第二次：服务器接收后，并发送ACK=1,ack=u+1,seq=v,服务器进入CLOSE-WAIT状态<br>第三次：服务器发送FIN=1,ack=u+1,seq=w,ACK=1给客户端，服务器进入LAST-ACK状态<br>第四次：客户端接收后并发送ACK=1,ack=w+1,seq=u+1，并且进入TIME-WAIT状态等待2msl后进入CLOSED状态，服务器接收到请求进入CLOSED状态</p><p><strong>为什么time_wait有个2msl</strong><br>1.确保最后发送的ACK可以到达服务器，因为这个有可能丢失，一旦服务器处于LAST-ACK状态一直接收到不到对方的确认则会超时重传；<br>2.再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。 </p><p><strong>为什么tcp三次握手而要四次挥手</strong></p><p>因为FIN只表示对方不再发送数据但是可以接受数据，自己也可以发送数据；再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h1 id="TCP出现的故障"><a href="#TCP出现的故障" class="headerlink" title="TCP出现的故障"></a>TCP出现的故障</h1><p><strong>如果保持连接的时候，服务器突然出现故障？</strong><br>TCP有一个保活计时器，每当服务器接受到客户端的信息时都会复位这个计时器，保活计时器通常是2个小时，如果已经和服务器建立了连接，突然服务器发生故障，2个小时服务器都没有接受到来自客户端的消息，则服务器就会发送一个探测报文段，以后每隔75秒钟都发送一次，若连续发送10次探测报文段都没有回应，则服务器认为客户端出现故障，然后就关闭连接。</p><h1 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h1><p>参考博客：<a href="https://www.cnblogs.com/woaiyy/p/3554182.html" target="_blank" rel="noopener">https://www.cnblogs.com/woaiyy/p/3554182.html</a></p><h2 id="滑动窗口的具体实现"><a href="#滑动窗口的具体实现" class="headerlink" title="滑动窗口的具体实现"></a>滑动窗口的具体实现</h2><p>A给B发送数据<br>刚开始建立连接的时候B会告诉A自己的接收窗口大小，比如20<br>具体查看上列博客</p><h2 id="拥塞的控制"><a href="#拥塞的控制" class="headerlink" title="拥塞的控制"></a>拥塞的控制</h2><p>1.慢开始、拥塞控制<br>2.快重传、快恢复<br>条件判定：ssthresh，慢开始门限<br><em>1. cwnd &lt; ssthresh， 继续使用慢开始算法；比如2的n次方</em>2. cwnd &gt; ssthresh，停止使用慢开始算法，改用拥塞避免算法；y=kx<br>*3. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；<br>如果连续三个重复的确认则转入拥塞避免；如果超时重新转入慢开始</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP&lt;br&gt;
    
    </summary>
    
    
      <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2019/02/25/Redis/"/>
    <id>http://yoursite.com/2019/02/25/Redis/</id>
    <published>2019-02-25T08:52:31.000Z</published>
    <updated>2019-03-03T08:24:57.768Z</updated>
    
    <content type="html"><![CDATA[<p>redis</p><a id="more"></a><h1 id="Resis概述"><a href="#Resis概述" class="headerlink" title="Resis概述"></a>Resis概述</h1><h1 id="Redis支持的数据类型"><a href="#Redis支持的数据类型" class="headerlink" title="Redis支持的数据类型"></a>Redis支持的数据类型</h1><p>redis支持的五种基本数据类型：String,hash,list,set,zset</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p><strong>RDB</strong>：<br>DB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。<br>也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。<br>可以通过配置设置自动做快照持久化的方式<br><strong>AOF</strong>：<br>redis会将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)。</p><p>当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存 write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉redis我们想要 通过fsync函数强制os写入到磁盘的时机。有三种方式如下（默认是：每秒fsync一次）<br>–# Redis主从复制</p><h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><h2 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h2><p>分布式锁：当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。</p><h1 id="Redis淘汰策略"><a href="#Redis淘汰策略" class="headerlink" title="Redis淘汰策略"></a>Redis淘汰策略</h1><p>noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。<br>allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。<br>volatile-lru: 只限于设置了 expire （设置了生存时间）的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。<br>allkeys-random: 所有key通用; 随机删除一部分 key。<br>volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。<br>volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。</p><h1 id="Redis常见问题"><a href="#Redis常见问题" class="headerlink" title="Redis常见问题"></a>Redis常见问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>在高并发下,多线程同时查询同一个资源,如果缓存中没有这个资源,那么这些线程都会去数据库查找,对数据库造成极大压力,缓存失去存在的意义.打个比方,数据库是人,缓存是防弹衣,子弹是线程,本来防弹衣是防止子弹打到人身上的,但是当防弹衣里面没有防弹的物质时,子弹就会穿过它打到人身上.<br><strong>解决方法</strong><br>1.采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；<br>2.访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大量的key在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。<br><strong>解决方法</strong><br>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</p><h2 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a>缓存并发</h2><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。<br><strong>解决方法</strong><br>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux常见面试问题</title>
    <link href="http://yoursite.com/2019/02/19/Linux%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/19/Linux常见面试问题/</id>
    <published>2019-02-19T13:40:13.000Z</published>
    <updated>2019-03-05T02:54:16.780Z</updated>
    
    <content type="html"><![CDATA[<p>Linux命令</p><a id="more"></a><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>查看当前进程 ps(process)<br>ps [option] [–help]<br>参数：<br>-A列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程</p><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>lsof意为列出当前系统打开的文件<br>查看某个端口被占用情况<br>lsof -i:端口号</p><h1 id="netstat-amp-grep"><a href="#netstat-amp-grep" class="headerlink" title="netstat &amp; grep"></a>netstat &amp; grep</h1><p>netstat用于显示网络状态<br>netstat -lnt | grep 端口<br>-l或–listening 显示监控中的服务器的Socket。<br>-n或–numeric 直接使用IP地址，而不通过域名服务器。<br>-t或–tcp 显示TCP传输协议的连线状况。<br>-u或–udp 显示UDP传输协议的连线状况。   </p><p>grep用于查找文件里符合条件的字符串。</p><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>kill命令用于删除执行中的程序或工作。<br>kill [参数][进程号]<br>kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]<br>kill -9 123456表示彻底杀死进程，必杀令<br>kill -l 列出所有信号名称<br>只有第9种信号(SIGKILL)</p><p>才可以无条件终止进程，其他信号进程都有权利忽略。 下面是常用的信号：</p><p>HUP    1    终端断线</p><p>INT     2    中断（同 Ctrl + C）</p><p>QUIT    3    退出（同 Ctrl + \）</p><p>TERM   15    终止</p><p>KILL    9    强制终止</p><p>CONT   18    继续（与STOP相反， fg/bg命令）</p><p>STOP    19    暂停（同 Ctrl + Z）</p><p>系统会发送一个SIGTERM（-15）的信号给对应的程序。当程序接收到该signal后，将会发生以下的事情</p><p>程序立刻停止<br>当程序释放相应资源后再停止<br>程序可能仍然继续运行<br>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后在停止。但是也有程序可以在接受到信号量后，做一些其他的事情，并且这些事情是可以<br>配置的。如果程序正在等待IO，可能就不会立马做出相应。<br>也就是说，SIGTERM多半是会被阻塞的、忽略。</p><h1 id="tail-amp-head"><a href="#tail-amp-head" class="headerlink" title="tail &amp; head"></a>tail &amp; head</h1><p>tail filename //查看filename文件的后十行<br>tail -n 10 filename //查看filename文件的后十行<br>tail +20 filename //从文件的第20行开始查看到结束<br>tail -c 10 filename //显示文件的最后10个字符<br>head 是用来查看前几行<br>head -n 10 filename //查看filename文件的前十行</p><h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p>cat -n textfile1 &gt; textfile2//把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java并发之Semaphore</title>
    <link href="http://yoursite.com/2019/01/10/java%E5%B9%B6%E5%8F%91%E4%B9%8BSemaphore/"/>
    <id>http://yoursite.com/2019/01/10/java并发之Semaphore/</id>
    <published>2019-01-10T02:32:45.000Z</published>
    <updated>2019-01-10T06:07:51.101Z</updated>
    
    <content type="html"><![CDATA[<p>java并发之Semaphore<br><a id="more"></a></p><h1 id="Semaphore概述"><a href="#Semaphore概述" class="headerlink" title="Semaphore概述"></a>Semaphore概述</h1><p>Semaphore是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。Semaphore是一种计数信号量，用于管理一组资源，内部是基于AQS的共享模式。它相当于给线程规定一个量从而控制允许活动的线程数。</p><p>就是相当于同一时刻只有指定的线程数在执行任务，与线程池相似</p><h1 id="Semaphore源码"><a href="#Semaphore源码" class="headerlink" title="Semaphore源码"></a>Semaphore源码</h1><p>主要方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Semaphore(<span class="keyword">int</span> permits):构造方法，创建具有给定许可数的计数信号量并设置为非公平信号量。</span><br><span class="line"></span><br><span class="line">Semaphore(<span class="keyword">int</span> permits,<span class="keyword">boolean</span> fair):构造方法，当fair等于<span class="keyword">true</span>时，创建具有给定许可数的计数信号量并设置为公平信号量。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span>:从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> n)</span>:从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n</span>=<span class="number">2</span>，就相当于一辆车占了两个车位。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span>:释放一个许可，将其返回给信号量。就如同车开走返回一个车位。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> n)</span>:释放n个许可。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span>：当前可用的许可数。</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Semaphore写的小Demo"><a href="#使用Semaphore写的小Demo" class="headerlink" title="使用Semaphore写的小Demo"></a>使用Semaphore写的小Demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Semaphore semaphore)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="comment">//获取许可</span></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"start running"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"releasing......."</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.method(semaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>Thread-1start running<br>Thread-0start running<br>Thread-1releasing…….<br>Thread-0releasing…….<br>Thread-3start running<br>Thread-4start running<br>Thread-3releasing…….<br>Thread-4releasing…….<br>Thread-2start running<br>Thread-2releasing…….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java并发之Semaphore&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发之CyclicBarrier</title>
    <link href="http://yoursite.com/2019/01/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BCyclicBarrier/"/>
    <id>http://yoursite.com/2019/01/09/java并发之CyclicBarrier/</id>
    <published>2019-01-09T07:20:46.000Z</published>
    <updated>2019-01-10T05:47:40.599Z</updated>
    
    <content type="html"><![CDATA[<p>java并发之CyclicBarrier</p><a id="more"></a><h1 id="CyclicBarrier概述"><a href="#CyclicBarrier概述" class="headerlink" title="CyclicBarrier概述"></a>CyclicBarrier概述</h1><p>CyclicBarrier是一个同步工具类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p><p>上面的讲解比较官方，第一次看的时候一直理解错了，自我解释：就是班级旅游，全班20个人，然后聚集的时候来的早的人就要等来晚的人，然后再能进行下一步工作，而这里的一组线程互相等待就是来的早的人等待来的晚的人，而某个公共屏障点就是最后一个人到达的时候。（当然打破阻塞还有其他办法）</p><h1 id="CyclicBarrier底层源码"><a href="#CyclicBarrier底层源码" class="headerlink" title="CyclicBarrier底层源码"></a>CyclicBarrier底层源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier //时执行预定义的操作。</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties)</span><br><span class="line"><span class="comment">//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier //时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction)</span><br><span class="line"><span class="comment">//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回当前在屏障处等待的参与者数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回要求启动此 barrier 的参与者数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//查询此屏障是否处于损坏状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//将屏障重置为其初始状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取“独占锁(lock)”</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存“当前的generation”</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若“当前generation已损坏”，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将“count计数器”-1</span></span><br><span class="line">       <span class="keyword">int</span> index = --count;</span><br><span class="line">       <span class="comment">// 如果index=0，则意味着“有parties个线程到达barrier”。</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果barrierCommand不为null，则执行该动作。</span></span><br><span class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">// 唤醒所有等待线程，并更新generation。</span></span><br><span class="line">               nextGeneration();</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，</span></span><br><span class="line">        <span class="comment">// 当前线程才继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果等待过程中，线程被中断，则执行下面的函数。</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果“当前generation已经损坏”，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果“generation已经换代”，则返回index。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“独占锁(lock)”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到达屏障的线程都执行await()方法,开始阻塞<br>解除阻塞的情况有以下几种<br>1）最后一个线程调用await()<br>2）当前线程被中断<br>3）其他正在该CyclicBarrier上等待的线程被中断<br>4）其他正在该CyclicBarrier上等待的线程超时<br>5）其他某个线程调用该CyclicBarrier的reset()方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java并发之CyclicBarrier&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发之CountDownLatch</title>
    <link href="http://yoursite.com/2019/01/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch/"/>
    <id>http://yoursite.com/2019/01/09/java并发之CountDownLatch/</id>
    <published>2019-01-09T02:39:21.000Z</published>
    <updated>2019-01-10T02:48:25.377Z</updated>
    
    <content type="html"><![CDATA[<p>java并发之CountDownLatch</p><a id="more"></a><h1 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h1><p>CountDownLatch是java1.5的时候引入的，同期引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下</p><p><strong>作用：使得一个线程或者多个线程等待其他线程工作完成后再执行任务</strong><br>其CountDownLatch是一个闭锁的实现，其闭锁的概念请参考我的另一篇文章——java同步机制<a href="https://liuwei110.github.io/2018/12/29/java%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://liuwei110.github.io/2018/12/29/java%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</a></p><h1 id="CountDownLatch的工作原理"><a href="#CountDownLatch的工作原理" class="headerlink" title="CountDownLatch的工作原理"></a>CountDownLatch的工作原理</h1><p>CountDownLatch是通过计数器count来实现的，其初始值是线程的数量。每当一个线程完成任务后计数器就会减一，当计数器值为0的时候，则意味着所有线程已经完成任务，则闭锁上的等待线程就可以开始执行任务了</p><h1 id="CountDownLatch的源码"><a href="#CountDownLatch的源码" class="headerlink" title="CountDownLatch的源码"></a>CountDownLatch的源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>; <span class="comment">//指定计数的次数，只能被设置1次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;          <span class="comment">//调用此方法则计数减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException   <span class="comment">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。</span></span></span><br><span class="line"><span class="function">Public Long <span class="title">getCount</span><span class="params">()</span></span>;           <span class="comment">//得到当前的计数</span></span><br><span class="line"><span class="function">Public <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="comment">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。</span></span></span><br></pre></td></tr></table></figure><p>CountDownLatch是依赖AQS来实现的<br>主要关注await()和countDown()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**小Demo**</span><br><span class="line">countDown()方法建议放置在<span class="keyword">finally</span>中</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     countDownLatch.await();</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br>子线程Thread-1正在执行<br>子线程Thread-2正在执行<br>子线程Thread-1执行完毕<br>子线程Thread-2执行完毕<br>子线程Thread-0正在执行<br>子线程Thread-0执行完毕</p><h1 id="CountDownLatch的使用场景"><a href="#CountDownLatch的使用场景" class="headerlink" title="CountDownLatch的使用场景"></a>CountDownLatch的使用场景</h1><p>参考博客：<a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">http://www.importnew.com/15731.html</a><br>（1）开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</p><p>（2）应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><p>（3）确保一个计算不会执行，直到所需要的资源被初始化。</p><p>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。</p><p>开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。</p><p>死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java并发之CountDownLatch&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java并发之ThreadLocal</title>
    <link href="http://yoursite.com/2019/01/07/java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/"/>
    <id>http://yoursite.com/2019/01/07/java并发之ThreadLocal/</id>
    <published>2019-01-07T07:28:53.000Z</published>
    <updated>2019-01-08T04:58:17.044Z</updated>
    
    <content type="html"><![CDATA[<p>java并发之ThreadLocal</p><a id="more"></a><h1 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h1><p>ThreadLocal，被叫做线程本地变量，为每一个线程提供了变量副本。</p><h1 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   T value = initialValue();<span class="comment">//null</span></span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getMap函数及其ThreadLocalMap的初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看出 Thread 类种有个属性是ThreadLocalMap的实例对象，而ThreadLocalMap又是ThreadLocal的内部类</p><p>为了自己好记一点：<br>简述set方法：首先获取当前线程实例，然后获取线程实例的属性ThreadLocalMap实例，如果不为空，则map.set(this,value),如果为空则create一个ThreadLocalMap同时添加value;</p><p>简述get方法：第一步永远都是获取当前线程实例对象。再获取ThreadLocalMap的实例对象。如果不为空，根据key=this获取Entry,如果Map容器为空，则设置初始值</p><p><strong>为什么不直接用线程id来作为ThreadLocalMap的key？</strong><br>　　这一点很容易理解，因为直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？<br>　　而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个ThreadLocal对象都可以由这个对象的名字唯一区分，所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。</p><h1 id="ThreadLocal-的作用"><a href="#ThreadLocal-的作用" class="headerlink" title="ThreadLocal 的作用"></a>ThreadLocal 的作用</h1><p>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用。作用：提供一个线程内公共变量（比如本次请求的用户信息），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个私有的变量副本，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p><p><strong>更好的了解ThreadLocal</strong><br>举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。</p><h1 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h1><p>参考一个博客：<br><a href="https://blog.csdn.net/qq_36632687/article/details/79551828" target="_blank" rel="noopener">https://blog.csdn.net/qq_36632687/article/details/79551828</a><br>最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java并发之ThreadLocal&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java之内存泄漏</title>
    <link href="http://yoursite.com/2019/01/02/java%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2019/01/02/java之内存泄漏/</id>
    <published>2019-01-02T05:27:27.000Z</published>
    <updated>2019-03-04T12:55:11.175Z</updated>
    
    <content type="html"><![CDATA[<p>内存泄漏 Memory Leak<br><a id="more"></a></p><h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><p>Memory Leak<br>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。</p><p>在Java中内存泄漏的对象符合这两个条件：1.首先这些对象是可达的；2.这些对象是无用的，即后续的程序中并不使用这些对象。这样我们判定为内存泄漏。因为这些对象不无法被GC回收，却又占用着内存。</p><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏</p><h1 id="内存泄漏发生的场景"><a href="#内存泄漏发生的场景" class="headerlink" title="内存泄漏发生的场景"></a>内存泄漏发生的场景</h1><p><strong>静态集合类</strong><br>像HashMap、Vector等集合类，申明为静态变量时候，由于静态变量的生命周期与应用程序一致，并且他们的所有引用的对象Object都无法释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">v.add(o);</span><br><span class="line">o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环申请Object 对象，并将所申请的对象放入静态的Vector v 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。</p><p><strong>当集合里面的对象属性被修改后，再调用remove()方法时不起作用</strong><br>（前提条件：重写equals()和hashcode()方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>,<span class="string">"pwd1"</span>,<span class="number">25</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="string">"pwd2"</span>,<span class="number">26</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="string">"pwd3"</span>,<span class="number">27</span>);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:3 个元素!</span></span><br><span class="line">p3.setAge(<span class="number">2</span>); <span class="comment">//修改p3的年龄,此时p3元素对应的hashcode值发生改变</span></span><br><span class="line">set.remove(p3); <span class="comment">//此时remove不掉，造成内存泄漏</span></span><br><span class="line">set.add(p3); <span class="comment">//重新添加，居然添加成功</span></span><br><span class="line">System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:4 个元素!</span></span><br><span class="line"><span class="keyword">for</span> (Person person : set)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>监听器</strong><br>当程序中使用了监听器的时候，如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，而增加了内存泄漏的机会。//todo</p><p><strong>各种连接</strong></p><p>比如数据库连接、网络连接等，除非显示的使用了close()方法关闭，否则是不会自动被GC回收的。对于Resultset和Statement就会立即为对象可以不进行显式回收，但是对于Connection一定要关闭，因为Connection关闭后其Resultset 和Statement 就会立即为null;但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset、Statement对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p><p><strong>内部类和外部模块的引用</strong></p><p>内部类的引用是比较容易遗忘的一种,而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用,例如程序员A 负责A 模块,调用了B 模块的一个方法如:<br>public void registerMsg(Object b);<br>这种调用就要非常小心了,传入了一个对象,很可能模块B就保持了对该对象的引用,这时候就需要注意模块B 是否提供相应的操作去除引用。</p><p><strong>单例模式</strong><br>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B类采用单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> A a;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> B instance=<span class="keyword">new</span> B();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存泄漏 Memory Leak&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Exception" scheme="http://yoursite.com/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>java同步机制</title>
    <link href="http://yoursite.com/2018/12/29/java%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/29/java同步机制/</id>
    <published>2018-12-29T02:42:21.000Z</published>
    <updated>2019-02-25T07:54:19.209Z</updated>
    
    <content type="html"><![CDATA[<p>锁的相关概念<br>Synchronized 和 Lock</p><a id="more"></a><p>其锁的概念参照了作者：a2615381<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/a2615381/article/details/79617128" target="_blank" rel="noopener">https://blog.csdn.net/a2615381/article/details/79617128</a> </p><h1 id="锁的相关概念"><a href="#锁的相关概念" class="headerlink" title="锁的相关概念"></a>锁的相关概念</h1><p><strong>可重入锁:</strong><br>如果锁具有可冲入性，则他就是可重入锁。<br>即如下面代码，如果一个线程获取锁进入了method1方法，这时候要执行带有synchronized的method2方法，<br>这时候线程不需要申请锁，直接执行method2方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可中断锁</strong><br>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。<br>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p><strong>公平锁</strong><br>线程获取锁的顺序是按照申请锁的顺序<br><strong>非公平锁</strong><br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p><strong>互斥锁</strong><br>互斥锁在Java中的具体实现就是ReentrantLock<br><strong>读写锁</strong><br>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。<br>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br><strong>自旋锁</strong><br>旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。<br>/////////以下三种锁是指锁的状态，并且是针对Synchronized，来实现高效<br><strong>偏向锁</strong><br>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br><strong>轻量级锁</strong><br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br><strong>重量级锁</strong><br>是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。<br>///////////////<br><strong>闭锁</strong></p><p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动指导其他活动都完成后才继续执行。CountDownLatch就是一种灵活的闭锁实现。</p><p><strong>活锁</strong></p><p>LiveLock是一种形式活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。活锁通常发送在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列开头，因此处理器将被反复调用，并返回相同的结果。</p><p><strong>无锁</strong></p><p>要保证现场安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p><p>无状态编程。无状态代码有一些共同的特征：不依赖于存储在对上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。</p><p>线程本地存储，参考我的另一个博客有关ThreadLocal</p><p>volatile</p><p>CAS（Compare And Swap）</p><p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>java内置关键字，非公平、可重入锁</p><h2 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h2><ol><li><p>Synchronized 同步语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="comment">//作用于当前对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 同步语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//作用于类上</span></span><br><span class="line"><span class="keyword">synchronized</span>(Demo.class)&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 同步语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Synchronized 修饰方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="comment">//作用于当前对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 修饰方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.Synchronized 修饰静态方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="comment">//作用域于当前对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 修饰静态方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Synchronized的缺点"><a href="#Synchronized的缺点" class="headerlink" title="Synchronized的缺点"></a>Synchronized的缺点</h2><p>一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁<br>释放锁的两种情况：<br>1.线程执行完代码块，自动释放锁<br>2.线程执行发生异常，jvm让线程自动释放锁<br>如果线程无法释放锁，则其他线程只能一直等待下去。</p><p>另一种情况就是，如果多线程只是执行读操作，当一个线程获取的读，则其他线程还是需要继续等待下去<br>并且Synchronized无法知道线程有没有成功获取到锁<br>而上面的这些问题Lock均可以办到</p><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>java.util.concurrent.locks包中常用的类和接口。<br>首先是Lock类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;<span class="comment">//获取锁，如果锁已被其他线程获取，则进行等待</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *获取锁成功返回true;失败返回false,也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。</span></span><br><span class="line"><span class="comment">     *如果一开始拿到锁或者在等待期间内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    拿到了锁，则返回<span class="keyword">true</span>。</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;<span class="comment">//释放锁</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>lockInterruptibly()方法比较特殊，如果使用这个方法去获取锁，如果线程正在等待这个锁，则可以中断响应即中断线程的等待状态</p><h2 id="ReenterantLock"><a href="#ReenterantLock" class="headerlink" title="ReenterantLock"></a>ReenterantLock</h2><p>ReenterantLock是唯一实现Lock接口的类，并且</p><h2 id="ReadWriteLock和ReentrantReadWriteLock"><a href="#ReadWriteLock和ReentrantReadWriteLock" class="headerlink" title="ReadWriteLock和ReentrantReadWriteLock"></a>ReadWriteLock和ReentrantReadWriteLock</h2><p>ReadWriteLock也是一个接口,里面就定义了两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReentrantReadWriteLock实现了ReadWriteLock接口<br>使用读写锁实现多线程读操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteDemo</span> </span>&#123;</span><br><span class="line">ReentrantReadWriteLock rwlLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ReadWriteDemo testDemo = <span class="keyword">new</span> ReadWriteDemo();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">testDemo.read(Thread.currentThread());</span><br><span class="line">&#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">testDemo.read(Thread.currentThread());</span><br><span class="line">&#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">rwlLock.readLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(thread.getName()+<span class="string">"正在读。。。。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">rwlLock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用ReentrantLock和Condition来代替wait-和notify-来唤醒指定的线程"><a href="#使用ReentrantLock和Condition来代替wait-和notify-来唤醒指定的线程" class="headerlink" title="使用ReentrantLock和Condition来代替wait()和notify()来唤醒指定的线程"></a>使用ReentrantLock和Condition来代替wait()和notify()来唤醒指定的线程</h2><p>另一个解决方法：以加一个细粒度的锁，假如说每个线程锁住的对象不同，那就就可以根据这个对象来进行唤醒<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition condition  = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">"执行 await1 方法"</span>);</span><br><span class="line">condition.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">System.out.println(<span class="string">"await1 锁释放了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">"执行 await2 方法"</span>);</span><br><span class="line">condition2.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">System.out.println(<span class="string">"await2锁释放了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">"执行signal1方法"</span>);</span><br><span class="line">condition.signal();</span><br><span class="line">System.out.println(<span class="string">"通知了await1 "</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">"执行signal2方法"</span>);</span><br><span class="line">condition2.signal();</span><br><span class="line">System.out.println(<span class="string">"通知了await2 "</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Synchronized和Lock对比"><a href="#Synchronized和Lock对比" class="headerlink" title="Synchronized和Lock对比"></a>Synchronized和Lock对比</h1><p>Synchronized是一个内置关键字，而Lock是一个接口<br>Synchronized是非公平可重入锁，Lock（ReentrantLock）默认是非公平可重入锁，但是可以定位为公平锁<br>Synchronized不需要手动去加锁释放锁，而Lock需要<br>Synchronized不可以让等待锁的线程响应中断，而Lock可以<br>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>Lock可以提高多个线程进行读操作的效率。</p><p>总结：在竞争不太激烈的时候两者性能差不多，而竞争十分激烈的时候，则Lock的性能大于synchronized</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>java 提供了一个稍弱的同步机制——volatile,用来确保将变量的更新通知到其他线程。将变量申明为volatile类型。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>== 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 ==<br>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p><p>　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p><p><strong>volatile具备的特性</strong><br>1.可见性</p><p>2.禁止指令重排：有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p><p>对volatile变量写操作时，会在写操作后加入一条store<br>屏障指令，将本地内存中的共享变量值刷新到主内存</p><p>对volatile变量读操作时，会在读操作前加入一条load<br>屏障指令，从主内存中读取共享变量</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;锁的相关概念&lt;br&gt;Synchronized 和 Lock&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java锁之AQS</title>
    <link href="http://yoursite.com/2018/12/29/java%E9%94%81%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2018/12/29/java锁之AQS/</id>
    <published>2018-12-29T02:41:55.000Z</published>
    <updated>2019-01-02T04:32:38.193Z</updated>
    
    <content type="html"><![CDATA[<p>谈到ReentrantLock不得不谈AQS(队列同步器AbstractQueueSynchronizer)</p><a id="more"></a><p>结合ReentrantLock分析<br>参考博客<br>来源：CSDN<br>网址:<a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a><br>网址：<a href="https://www.cnblogs.com/java-zhao/p/5131544.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-zhao/p/5131544.html</a></p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>其ReenterantLock的实现需要提到其内部类Sync的父类说起，也就是AbstractQueuedSynchronizer（AQS）。<br>AQS是一个基于FIFO等待队列实现的用于实现一个同步器框架的基础的框架<br>AQS的核心思想是基于volatile int state这样的一个属性同时配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。当state的值为0的时候，标识改Lock不被任何线程所占有。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p><img src="https://github.com/liuwei110/liuwei110.github.io/commits/master/photo/AQS01.png" alt="CLH队列"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>先看看ReentrantLock的源码<br>只贴了主要代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;<span class="comment">//同步器：内部类Sync的一个引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从下面的主要函数可以看出ReentrantLock的实现依赖于Sync</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;<span class="comment">//默认是非公平锁</span></span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>AQS的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取锁的方法lock的语义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();<span class="comment">//中断自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义</span></span><br><span class="line">    <span class="comment">//????为啥直接抛出异常？？AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;         </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">   <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此方法用于加入队列尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS"自旋"，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。该线程下一部该干什么了？进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS中Node的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步等待队列（双向链表）中的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 线程被取消了 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 如果前驱节点的等待状态是SIGNAL，表示当前节点将来可以被唤醒，那么当前节点就可以安全的挂起了 </span></span><br><span class="line"><span class="comment">         * 否则，当前节点不能挂起 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**线程正在等待条件*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** 一个标记：用于表明该节点正在独占锁模式下进行等待 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//值就是前四个int（CANCELLED/SIGNAL/CONDITION/PROPAGATE），再加一个0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">/**前驱节点*/</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**后继节点*/</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**节点中的线程*/</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回该节点前一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123; <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123; <span class="comment">// 用于addWaiter中</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谈到ReentrantLock不得不谈AQS(队列同步器AbstractQueueSynchronizer)&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java基础之线程池</title>
    <link href="http://yoursite.com/2018/12/27/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/12/27/java基础之线程池/</id>
    <published>2018-12-27T08:04:08.000Z</published>
    <updated>2018-12-29T07:52:26.751Z</updated>
    
    <content type="html"><![CDATA[<p>java基础之线程池</p><a id="more"></a><h1 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> corePoolSize,  　　　　　　　　　　　　　　//核心池的大小。</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,　　                  //池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,　　　　　　　　　　     //当线程数大于corePoolSize时，终止前多余的空闲线程等待新任务的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,　　　　　　　　　　　　　    //keepAliveTime时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,    //存储还没来得及执行的任务</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,　　　　  //执行程序创建新线程时使用的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler   //由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p><strong>1.corePoolSize</strong><br><strong>2.maximumPoolSize</strong><br><strong>3.keepAliveTime</strong><br><strong>4.unit</strong><br><strong>5.workQueue</strong><br><strong>6.threadFactory</strong><br><strong>7.handler</strong></p><h1 id="线程池的实现过程"><a href="#线程池的实现过程" class="headerlink" title="线程池的实现过程"></a>线程池的实现过程</h1><p>池中线程数量小于corePoolSize的时候，新任务不用排队直接添加新线程<br>当池中线程数量大于corePoolSize的时候且workQueue队列未满，则将任务加入到workQueue中<br>当池中线程数量大于corePoolSize的时候且workQueue队列已满，且线程池数量小于maximumPoolSize，添加新的线程池来处理任务<br>当线程池的数量大于corePoolSize的时候且workQueue队列已满，且线程池数量大于maximumPoolSize，则执行拒绝策略</p><h1 id="常见的线程池"><a href="#常见的线程池" class="headerlink" title="常见的线程池"></a>常见的线程池</h1><p>最顶部的接口是java.util.concurrent里的Executor接口。<br><img src="https://img-blog.csdnimg.cn/20181125124646843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTYwMDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>newSingleThreadPool ( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService   </span><br><span class="line">                 (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,   </span><br><span class="line">                                       <span class="number">0L</span>, TimeUnit.MILLISECONDS,   </span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));   </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>newFixedThreadPool ( )</strong><br>为什么这里corePoolsize和maximumpoolsize是相同的？这是因为他的队列是无界的，当队列是无界的时候maximumpoolsize是没有意义的。keepAliveTime和unit的设值表名什么？——该实现不想keep alive！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,   </span><br><span class="line"></span><br><span class="line">                                        <span class="number">0L</span>, TimeUnit.MILLISECONDS,   </span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());   </span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p><strong>newCachedThreadPool( )</strong><br>看函数，这个首先呢线程池是无界的了。其次呢这里在队列的选择上使用了synchronousQueue<runnable>，这意味着每个插入操作必须等待另一个线程的移除操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,   </span><br><span class="line">                                         <span class="number">60L</span>, TimeUnit.SECONDS,   </span><br><span class="line">                                        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></runnable></p><p><strong>newScheduledThreadPool</strong><br>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p><h1 id="线程池排队的策略"><a href="#线程池排队的策略" class="headerlink" title="线程池排队的策略"></a>线程池排队的策略</h1><p>排队有三种通用策略<br><strong>直接提交</strong><br>SynchronousQueue<br><strong>无界队列</strong><br>LinkedBlockingQueue<br><strong>有界队列</strong><br>ArrayBlockingQueue</p><h1 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h1><h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>换个方法来说。就是老板就算借了工人过来但是任务还是一直来人手又不够了，但是已经没办法继续借工人了。这个时候呢就要考虑拒绝任务了</p><h3 id="策略1："><a href="#策略1：" class="headerlink" title="策略1："></a>策略1：</h3><p><strong>CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度</strong><br>就这个策略来说并不想放弃执行任务，然后就让executor本身来执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="策略2："><a href="#策略2：" class="headerlink" title="策略2："></a>策略2：</h3><p><strong>abortPolicy:处理程序遭到拒绝将抛出运行RejectedExecutionException</strong><br>也就是丢弃任务，并且抛出一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="策略3："><a href="#策略3：" class="headerlink" title="策略3："></a>策略3：</h3><p><strong>discardPolicy:不能处理的任务将直接被删除</strong><br>这个策略和策略2一样也是丢弃任务，但是并不抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="策略4："><a href="#策略4：" class="headerlink" title="策略4："></a>策略4：</h3><p><strong>discardOldestPolicy:如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">               e.execute(r);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础之线程池&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据库之进阶之路</title>
    <link href="http://yoursite.com/2018/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/12/27/数据库之进阶之路/</id>
    <published>2018-12-27T08:03:37.000Z</published>
    <updated>2019-01-03T05:31:01.065Z</updated>
    
    <content type="html"><![CDATA[<p>索引、存储引擎<br><a id="more"></a></p><h1 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h1><p>普通索引：仅加速查询</p><p>唯一索引：加速查询 + 列值唯一（可以有null）</p><p>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</p><p>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p><p>全文索引：对文本的内容进行分词，进行搜索</p><p>ps：<br>索引合并，使用多个单列索引组合搜索<br>覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><h2 id="1-B-树索引"><a href="#1-B-树索引" class="headerlink" title="1.B+树索引"></a>1.B+树索引</h2><p>是大多数 MySQL 存储引擎的默认索引类型。<br><strong>B+树的原理</strong><br>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。<br>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。<br><strong>与B树的区别</strong><br>B树的每个节点都存储数据上，而B+树只有叶子节点存储了数据<br>B+树的叶子节点有指针相连，方便区间查询</p><p><strong>操作</strong><br>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。<br>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p><p><strong>与红黑树的比较</strong></p><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logd N)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。<br> (二）利用磁盘预读特性(///???//todo)</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。<br>———————————————分界线————————————————-<br>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><h2 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2.哈希索引"></a>2.哈希索引</h2><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><p>无法用于排序与分组；<br>只支持精确查找，无法用于部分查找和范围查找。<br>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h2 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3.全文索引"></a>3.全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h2 id="4-空间索引"><a href="#4-空间索引" class="headerlink" title="4.空间索引"></a>4.空间索引</h2><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h2><p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。(如果在应用中执行大量insert和update操作，可选择。)</p><p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p><p>外键：InnoDB 支持外键。</p><p>备份：InnoDB 支持在线热备份。</p><p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p><p>其它特性：MyISAM 支持压缩表和空间数据索引。</p><p>全文索引:MyISAM支持全文类型索引，而InnoDB不支持全文索引</p><p>性能:MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</p><h1 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MYSQL中提供了两种封锁粒度：表级锁和行级锁</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>排它锁（Exclusive），简写为 X 锁，又称写锁。<br>共享锁（Shared），简写为 S 锁，又称读锁。</p><p>只有当都是共享锁的时候才兼容</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁在原来的X/S锁的基础上引入了IX/IS锁。IX/IS都是属于表锁用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；<br>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p><p><strong>各种锁的兼容：</strong></p><p>|    -    |    X   |    IX   |    S     |    IS     |<br>|    X    |    -   |    -    |  -    |    -    |<br>|   IX    |    -   |    √    |    -    |    √    |<br>|    S    |    -   |    -    |    √    |    √    |<br>|   IS    |    -   |    √    |    √    |    √    |</p><p>要领：<br>任意的IS/IX之间是兼容的，它们只能表达想加锁的意向，并不是真正的加锁；<br>S锁之和IS、S锁兼容</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p><strong>一级封锁协议</strong><br>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。<br>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><strong>二级封锁协议</strong><br>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><strong>三级封锁协议</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引、存储引擎&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库之优化</title>
    <link href="http://yoursite.com/2018/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/12/27/数据库之优化/</id>
    <published>2018-12-27T08:03:11.000Z</published>
    <updated>2019-01-04T07:07:06.206Z</updated>
    
    <content type="html"><![CDATA[<p>数据库优化<br><a id="more"></a></p><h2 id="表结构优化"><a href="#表结构优化" class="headerlink" title="表结构优化"></a>表结构优化</h2><h2 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h2><p><strong>explain</strong><br>使用explain关键字来分析select查询语句<br>比较重要的字段有：<br>    select_type : 查询类型，有简单查询、联合查询、子查询等<br>    key : 使用的索引<br>    rows : 扫描的行数</p><p><strong>慢查询日志</strong><br>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，MySQLl数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>查询慢日志参数：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span>  <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br></pre></td></tr></table></figure></p><p>修改当前配置:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> 变量名 = 值;</span><br></pre></td></tr></table></figure></p><p><strong>优化数据访问</strong></p><ol><li>减少请求的数据量<br>只返回必要的列：最好不要使用 SELECT * 语句。<br>只返回必要的行：使用 LIMIT 语句来限制返回的数据。<br>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li><li>减少服务器端扫描的行数<br>最有效的方式是使用索引来覆盖查询。</li></ol><p>重构查询方式</p><ol><li>切分大查询<br>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</li></ol><p>DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);<br>rows_affected = 0<br>do {<br>    rows_affected = do_query(<br>    “DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000”)<br>} while rows_affected &gt; 0</p><ol start="2"><li>分解大连接查询<br>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</li></ol><p>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。<br>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。<br>减少锁竞争；<br>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。<br>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>最左前缀匹配原则，<br>对 where,on,group by,order by 中出现的列使用索引<br>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);<br>为较长的字符串使用前缀索引<br>对于like查询，”%”不要放在前面。 </p><h2 id="分区分表"><a href="#分区分表" class="headerlink" title="分区分表"></a>分区分表</h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库优化&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库之基础</title>
    <link href="http://yoursite.com/2018/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/27/数据库之基础/</id>
    <published>2018-12-27T08:02:58.000Z</published>
    <updated>2019-01-03T05:58:57.505Z</updated>
    
    <content type="html"><![CDATA[<p>数据库<br>事务<br><a id="more"></a></p><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><p>事务就是指满足ACID的一系列操作，可以使用 commit提交一个事务，也可以使用rollback回滚</p><h2 id="2-数据库事务的四个特性ACID"><a href="#2-数据库事务的四个特性ACID" class="headerlink" title="2.数据库事务的四个特性ACID"></a>2.数据库事务的四个特性ACID</h2><p><strong>原子性：</strong><br>事务的最小单位，不允许再被分割。意味着执行的话要么一起成功，要么一起失败。如果事务在执行的过程中发生错误，则回滚到事务执行前最初状态<br><strong>一致性：</strong><br>数据库在事务执行前后是保持一致的<br><strong>隔离性：</strong><br>一个事务在做出修改时在被提交之前对其他事务是不可见的<br><strong>持久性：</strong><br>一旦事务提交以后，做出的修改就被永久的保存在数据库中，并不会被回滚</p><h2 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h2><p>在讲事务隔离级别之前必须先看看为什么会出现隔离级别这种概念<br>上面讲到了事务必须是满足ACID四个特性的<br>在并发的情况下，事务的隔离性很难满足，因此会发生一系列并发一致性问题<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">参考文章-讲的超级好COPY</a></p><p><strong>并发导致的问题</strong><br><strong>丢失修改</strong><br>当T1和T2修改同一个数据的时候，T1先执行，T2后执行，当T1执行var=50以后，T2又执行var=100，将T1的执行结果覆盖。<br><img src="https://img-blog.csdnimg.cn/20181121101119565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTYwMDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>脏读</strong><br>当T1对数据进行修改后，这个时候T2读取了T1修改后的数据，但随后T1又执行了回滚操作，那么这个时候T2读出来的就是脏数据<br><img src="https://img-blog.csdnimg.cn/20181121101400151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTYwMDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>不可重复读</strong><br>（在一个事务范围内操作读取两次同一数据获取的内容不一样）<br>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br><img src="https://img-blog.csdnimg.cn/20181121113029706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTYwMDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>幻影读</strong><br>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。<br><img src="https://img-blog.csdnimg.cn/20181121121957755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTYwMDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>不可重复读和幻影读</strong><br>不可重复读重点在update，而幻影读重点在于insert和delete</p><p>说完并发情况下可能出现的问题后，再讲解下事务的隔离级别</p><p>==隔离级别==<br><strong>Read Uncommitted 未提交读</strong><br>事务中的修改哪怕没有提交对其他事务也是可见的。<br>最低的隔离级别，可能会导致脏读、不可重复读、幻影读<br><strong>Read Committed 提交读</strong><br>允许读取并发事务已经提交的数据<br>可以阻止脏读、但是幻读和不可重复读还是有可能发生<br><strong>Repeatable Read 可重复读</strong><br>保证在同一个事务中多次读取同样数据的结果是一样的。<br>可以阻止脏读和不可重复读，幻读可能会发生<br><strong>Serializable 可串行化</strong><br>最高隔离级别，让各个事务都逐个执行，完全遵循acid的隔离级别。该级别可以防止脏读、不可重复读以及幻读。但是严重的影响了程序的性能</p><p>==MYSQL默认采用REPEATABLE_READ级别，ORACLE默认采用READ_COMMITTED隔离级别==</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库&lt;br&gt;事务&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之创建型模式</title>
    <link href="http://yoursite.com/2018/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/12/26/设计模式之创建型模式/</id>
    <published>2018-12-26T05:41:27.000Z</published>
    <updated>2019-02-26T08:22:20.875Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式之创建型模式：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式</p><a id="more"></a><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式的特点："><a href="#单例模式的特点：" class="headerlink" title="单例模式的特点："></a>单例模式的特点：</h2><p>  1、单例类只能有一个实例。<br>　2、单例类必须自己创建自己的唯一实例。<br>　3、单例类必须给所有其他对象提供这一实例。</p><h2 id="常见的应用场景："><a href="#常见的应用场景：" class="headerlink" title="常见的应用场景："></a>常见的应用场景：</h2><p>数据库连接池<br>任务管理器<br>spring中bean默认是单例</p><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p><strong>懒汉式</strong><br>可以延迟加载，真正调用的时候才加载，但每次调用getSingleTon方法都要同步，并发效率低<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleTon <span class="title">getSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleTon==<span class="keyword">null</span>) &#123;</span><br><span class="line">singleTon=<span class="keyword">new</span> SingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>饿汉式</strong><br>线程安全，调用效率高；但是不能延迟加载；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon=<span class="keyword">new</span> SingleTon();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>双重检测校验</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleTon singleTon;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  SingleTon <span class="title">getSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleTon==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(SingleTon.class)&#123;</span><br><span class="line"><span class="keyword">if</span> (singleTon==<span class="keyword">null</span>) &#123;</span><br><span class="line">singleTon=<span class="keyword">new</span> SingleTon();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>静态内部类</strong><br>外部类有static属性，则不会像饿汉式那样启动的时候就立即加载对象<br>真正调用getSingleTon方法的时候才会加载静态内部类<br>兼备了高效调用和延迟加载的优势；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon singleTon=<span class="keyword">new</span> SingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  SingleTon <span class="title">getSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SingleTonClass.singleTon;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>枚举方式</strong><br>实现简单，枚举本身就是单例模式，可以避免反射和反序列化<br>但是无法延迟加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleTon &#123;</span><br><span class="line">singleTon;<span class="comment">//调用的时候直接SingleTon.singleTon</span></span><br><span class="line"><span class="comment">//单例模式可以有自己的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">getSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过反射和反序列化可以破解单例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SingleTon t1=SingleTon.getSingleTon();</span><br><span class="line">SingleTon t2=SingleTon.getSingleTon();</span><br><span class="line">Class&lt;SingleTon&gt; c1=(Class&lt;SingleTon&gt;) Class.forName(<span class="string">"com.单例模式.SingleTon"</span>);</span><br><span class="line">Constructor&lt;SingleTon&gt; constructor =  c1.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">SingleTon t3=constructor.newInstance();</span><br><span class="line">SingleTon t4=constructor.newInstance();</span><br><span class="line">System.out.println(t1);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">System.out.println(t3);</span><br><span class="line">System.out.println(t4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//com.单例模式.SingleTon@2a139a55</span></span><br><span class="line"><span class="comment">//com.单例模式.SingleTon@2a139a55</span></span><br><span class="line"><span class="comment">//com.单例模式.SingleTon@15db9742</span></span><br><span class="line"><span class="comment">//com.单例模式.SingleTon@6d06d69c</span></span><br></pre></td></tr></table></figure></p><p>破解：<br>就是在私有构造方法中加一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleTon!=<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleTon <span class="title">getSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleTon==<span class="keyword">null</span>) &#123;</span><br><span class="line">singleTon=<span class="keyword">new</span> SingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="工厂方法模式-amp-抽象工厂模式"><a href="#工厂方法模式-amp-抽象工厂模式" class="headerlink" title="工厂方法模式&amp;抽象工厂模式"></a>工厂方法模式&amp;抽象工厂模式</h1><p>实现创建者和调用者分离<br>工厂模式：简单工厂模式、工厂方法模式、抽象工厂模式</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式之创建型模式：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之消费者模式</title>
    <link href="http://yoursite.com/2018/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/12/20/设计模式之消费者模式/</id>
    <published>2018-12-20T09:55:45.000Z</published>
    <updated>2018-12-20T09:55:45.576Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring面试汇总</title>
    <link href="http://yoursite.com/2018/12/10/Spring%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/12/10/Spring面试汇总/</id>
    <published>2018-12-10T06:24:10.000Z</published>
    <updated>2019-02-18T07:39:38.824Z</updated>
    
    <content type="html"><![CDATA[<p>Spring面试汇总</p><a id="more"></a><p>参考博客：<a href="https://blog.csdn.net/a745233700/article/details/80959716" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/80959716</a></p><h1 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring?"></a>什么是Spring?</h1><p>Spring是为了解决企业开发复杂性的一种轻量级框架，其有两大核心的基本特征：IOC和AOP<br>IOC:控制反转，还有另一种说法叫做DI(依赖注入)，这是一种设计思想。<br>IOC就是根据你的需求去拿你需要的对象给你,利用java反射原理来创建对象，不需要自己手动去new一个。</p><p>IOC的三种注入方式：<br>1.构造器注入<br>2.set注入<br>（如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。）<br>3。注解注入</p><p>AOP：就是面向切面编程，在对程序不修改的情况下，对程序进行动态的扩展。可用于权限的认证、日志、事务的处理。spring aop主要利用动态代理——jdk动态代理和CGlib动态代理。其两者的不同在于jdk动态代理要求被代理的类必须实现一个接口（可以看代理模式那个笔记）。</p><p><strong>以下为摘抄：</strong></p><p>①JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法，当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。</p><h2 id="②如果目标类没有实现接口，那么Spring-AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code-Generation-Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。"><a href="#②如果目标类没有实现接口，那么Spring-AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code-Generation-Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。" class="headerlink" title=" ②如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。"></a> ②如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</h2><p>作者：a745233700<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/a745233700/article/details/80959716" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/80959716</a> </p><h1 id="Spring中几种bean的作用域"><a href="#Spring中几种bean的作用域" class="headerlink" title="Spring中几种bean的作用域"></a>Spring中几种bean的作用域</h1><p>1.singleton:这种是默认的，相当于单例模式；即不管接收到多少种请求，只有一个bean实例，由bean factory自身来维护的<br>2.prototype:每次请求提供一个实例相当于new<br>3.request:每一个来自客户端请求创建一个实例，请求完成后，就失效被gc回收<br>4.session:每个session中有一个bean的实例，在session过期后，bean会随之失效。<br>5,global-session:global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p><h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p>1.实例化bean<br>2.根据spring上下文对实例化bean进行配置——IOC注入</p><hr><p>3.如果这个bean实现了BeanNameAware接口，则调用它的setBeanName方法，此方法传递的是bean的id<br>4.如果这个bean实现了BeanFactoryAware接口，则调用它的setBeanFactory方法传递的是spring工厂自身<br>5.如果这个bean实现了ApplicationContextAware接口，则调用它的setAppplicationContext方法，传入spring上下文<br>6.如果这个bean实现了其他…Aware接口，则调用它的相关方法</p><hr><p>7.如果这个bean关联了BeanPostProcessor接口，调用postProessBeforeInitialization方法（经常被用作bean内容的修改）<br>8.如果bean在spring配置文件中配置了init-method属性，则调用其初始化方法<br>9.如果这个bean关联了BeanPostProcessor接口，调用postProessAfterInitialization方法</p><hr><p>10.当bean不再被需要进入清理阶段，如果bean实现了DisposableBean接口，则调用destory方法<br>11.如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><h1 id="spring中的自动装配"><a href="#spring中的自动装配" class="headerlink" title="spring中的自动装配"></a>spring中的自动装配</h1><p>（1）no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</p><p>（2）byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p><p>（3）byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p><p>（4）constructor：构造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</p><p>（5）autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring面试汇总&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构之SpringCloud</title>
    <link href="http://yoursite.com/2018/12/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B9%8BSpringCloud/"/>
    <id>http://yoursite.com/2018/12/01/微服务架构之SpringCloud/</id>
    <published>2018-12-01T07:24:53.000Z</published>
    <updated>2019-01-20T13:55:09.699Z</updated>
    
    <content type="html"><![CDATA[<p>微服务架构之SpringCloud<br><a id="more"></a></p><h1 id="SpringCloud概述"><a href="#SpringCloud概述" class="headerlink" title="SpringCloud概述"></a>SpringCloud概述</h1><p>SpringCloud是基于SpringBoot的一整套实现微服务的框架，提供了配置管理、服务的发现、断路器、智能路由，微代理，控制总线，一次性令牌，全局锁，主节点选举， 分布式session, 集群状态等公共组件。</p><h1 id="SpringCloud的使用"><a href="#SpringCloud的使用" class="headerlink" title="SpringCloud的使用"></a>SpringCloud的使用</h1><p>下面分别讲解SpringCloud分布式开发的五大核心<br>服务发现——Eureka<br>负载均衡——Ribbon<br>断路由——Hystrix<br>声明式服务调用——Feign<br>服务网关——Zuul<br>分布式配置——SpringCloud Config</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka,一个REST服务，主要分为服务器和客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化跟服务器的交互，作为轮询负载均衡器，并提供服务的故障切换支持</p><p>Eureka服务器：<br>导入相关的依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Eureka服务的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 6868</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #是否将自己注册在注册中心中</span><br><span class="line">    fetch-registry: false #是否从注册中心中获取信息</span><br></pre></td></tr></table></figure></p><p>在启动类上添加启动Eureka服务器的注释<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其Eureka客户端只需将配置文件中改成(通常根据name寻找服务)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: university-user</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true #是否将自己注册在注册中心中</span><br><span class="line">    fetch-registry: true #是否从注册中心中获取信息</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:6868/eureka/</span><br></pre></td></tr></table></figure></p><p>启动类上的注释变为<br>@EnableEurekaClient<br>或者使用通用注解@EnableDiscoveryClient（即使使用其他服务注册组件也可以通用）</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>主要提供负载均衡算法，其主要的一些负载均衡算法有：（默认是轮询）<br>1.简单轮询负载均衡<br>2.加权响应时间负载均衡<br>3.区域感知轮询负载均衡<br>4.随机负载均衡</p><p>Ribbon的使用：<br>1.添加Ribbon依赖<br>2.RestTemplate添加注解@LoadBalanced</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>在微服务架构中存在着很多个单元，如果其中一个单元出现问题，则会由于依赖关系导致整个系统的瘫痪；断路器就是为了解决这一问题。</p><p>Hystrix通过一下方式解决依赖隔离：<br>包裹请求：使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中执行<br>跳闸机制：当某服务的错误率超过一定的阈值时，Hystrix可以手动/自动的跳闸，停止请求该服务一段时间<br>资源隔离：Hystrix为每个依赖都维护一个小型线程池，如果线程池满了，则会拒绝请求，而不是排队等候<br>监控：实时依赖的统计和监控，例如:成功，失败（抛出异常），超时，线程拒绝<br>回退机制：当请求成功，失败（抛出异常），超时，线程拒绝或者断路器打开的时候执行回退逻辑，一般回退逻辑内容开发人员自己编写</p><p><strong>Hystrix的使用</strong><br>1.导入Hystrix的相关依赖<br>2.在启动类上添加注解@EnableHystrix<br>3.在调用微服务提供的接口函数上添加注解如：@HystrixCommand(fallbackMethod=”回退函数名”)//回退函数返回值要一致</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Dubbo和SpringCloud区别：<br>Dubbo的调用方式是RPC，而SpringCloud调用方式是Rest API</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务架构之SpringCloud&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>java异常</title>
    <link href="http://yoursite.com/2018/11/28/java%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/11/28/java异常/</id>
    <published>2018-11-28T09:14:17.000Z</published>
    <updated>2019-01-02T08:15:37.924Z</updated>
    
    <content type="html"><![CDATA[<p>java异常体系</p><a id="more"></a><h1 id="java异常体系"><a href="#java异常体系" class="headerlink" title="java异常体系"></a>java异常体系</h1><p><img src="" alt=""><br>在Java中将异常作为一个类，当作对象来处理。所有的异常的基类是——Throwable类，其下有两大子类Error,Exception。这三种异常通常可以分为三大类：系统错误、非运行时异常和运行时异常。</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>系统错误是由java虚拟机抛出的，Error类描述的是内部系统错误，如java虚拟机崩溃，一般程序自身无法处理。<br>如OutOfMemoryError、ThreadDeath等</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>Exception分为运行时异常和非运行时异常</p><p><strong>运行时异常</strong><br>运行时异常如NullPointerException、IndexOutOfBoundsException等,这些异常是不检查异常,程序中可以选择捕获处理,也可以不处理。这些异常一般是由程序逻辑错误引起的,程序应该从逻辑角度尽可能避免这类异常的发生。</p><p><strong>非运行时异常</strong><br>非运行时异常是RuntimeException以外的异常,类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常,如果不处理,程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常,一般情况下不自定义检查异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java异常体系&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Exception" scheme="http://yoursite.com/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>java异常之OOM</title>
    <link href="http://yoursite.com/2018/11/28/java%E5%BC%82%E5%B8%B8%E4%B9%8BOOM/"/>
    <id>http://yoursite.com/2018/11/28/java异常之OOM/</id>
    <published>2018-11-28T08:37:41.000Z</published>
    <updated>2018-12-29T07:52:28.634Z</updated>
    
    <content type="html"><![CDATA[<p>OOM(out of memory)<br><a id="more"></a><br>由于遇到的较少….目前只能写个概念…未完待续….</p><h1 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM?"></a>什么是OOM?</h1><p><strong>OOM</strong>即out of memory 翻译过来就是“内存用完了”，来源于java.lang.OutOfMemeoryError;<br>官方说明：Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。</p><h1 id="为什么会产生OOM"><a href="#为什么会产生OOM" class="headerlink" title="为什么会产生OOM"></a>为什么会产生OOM</h1><p>1.分配的太少了，不够用比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。<br>2.应用用的太多，且用完没有释放资源，浪费了。此时就会造成内存泄露或者内存溢出</p><h1 id="常见的OOM情况"><a href="#常见的OOM情况" class="headerlink" title="常见的OOM情况"></a>常见的OOM情况</h1><p>1.java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</p><p>2.java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</p><p>3.java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OOM(out of memory)&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Exception" scheme="http://yoursite.com/tags/Exception/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
