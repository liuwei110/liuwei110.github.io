<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux常见面试问题]]></title>
    <url>%2F2019%2F02%2F19%2FLinux%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Linux命令 ps查看当前进程 ps(process)ps [option] [–help]参数：-A列出所有的行程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程 lsoflsof意为列出当前系统打开的文件查看某个端口被占用情况lsof -i:端口号 # killkill命令用于删除执行中的程序或工作。kill [参数][进程号]kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;]kill -9 123456表示彻底杀死进程，必杀令kill -l 列出所有信号名称只有第9种信号(SIGKILL) 才可以无条件终止进程，其他信号进程都有权利忽略。 下面是常用的信号： HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + \） TERM 15 终止 KILL 9 强制终止 CONT 18 继续（与STOP相反， fg/bg命令） STOP 19 暂停（同 Ctrl + Z）系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该signal后，将会发生以下的事情 程序立刻停止当程序释放相应资源后再停止程序可能仍然继续运行大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后在停止。但是也有程序可以在接受到信号量后，做一些其他的事情，并且这些事情是可以配置的。如果程序正在等待IO，可能就不会立马做出相应。也就是说，SIGTERM多半是会被阻塞的、忽略。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发之Semaphore]]></title>
    <url>%2F2019%2F01%2F10%2Fjava%E5%B9%B6%E5%8F%91%E4%B9%8BSemaphore%2F</url>
    <content type="text"><![CDATA[java并发之Semaphore Semaphore概述Semaphore是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。Semaphore是一种计数信号量，用于管理一组资源，内部是基于AQS的共享模式。它相当于给线程规定一个量从而控制允许活动的线程数。 就是相当于同一时刻只有指定的线程数在执行任务，与线程池相似 Semaphore源码主要方法：12345678910111213Semaphore(int permits):构造方法，创建具有给定许可数的计数信号量并设置为非公平信号量。Semaphore(int permits,boolean fair):构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量。void acquire():从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位。void acquire(int n):从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n=2，就相当于一辆车占了两个车位。void release():释放一个许可，将其返回给信号量。就如同车开走返回一个车位。void release(int n):释放n个许可。int availablePermits()：当前可用的许可数。 12345678//有两个构造方法public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; 使用Semaphore写的小Demo1234567891011121314151617181920212223242526272829303132public class Demo &#123; public void method(Semaphore semaphore) &#123; try &#123; semaphore.acquire(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;//获取许可 System.out.println(Thread.currentThread().getName()+"start running"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"releasing......."); semaphore.release(); &#125; public static void main(String[] args) &#123; Demo demo = new Demo(); Semaphore semaphore = new Semaphore(2); for (int i = 0; i &lt; 5; i++) &#123; new Thread() &#123; public void run() &#123; demo.method(semaphore); &#125; &#125;.start(); &#125; &#125;&#125; 运行结果：Thread-1start runningThread-0start runningThread-1releasing…….Thread-0releasing…….Thread-3start runningThread-4start runningThread-3releasing…….Thread-4releasing…….Thread-2start runningThread-2releasing…….]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发之CyclicBarrier]]></title>
    <url>%2F2019%2F01%2F09%2Fjava%E5%B9%B6%E5%8F%91%E4%B9%8BCyclicBarrier%2F</url>
    <content type="text"><![CDATA[java并发之CyclicBarrier CyclicBarrier概述CyclicBarrier是一个同步工具类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 上面的讲解比较官方，第一次看的时候一直理解错了，自我解释：就是班级旅游，全班20个人，然后聚集的时候来的早的人就要等来晚的人，然后再能进行下一步工作，而这里的一组线程互相等待就是来的早的人等待来的晚的人，而某个公共屏障点就是最后一个人到达的时候。（当然打破阻塞还有其他办法） CyclicBarrier底层源码12345678910111213141516//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier //时执行预定义的操作。CyclicBarrier(int parties)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier //时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。CyclicBarrier(int parties, Runnable barrierAction)//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。int await()//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。int await(long timeout, TimeUnit unit)//返回当前在屏障处等待的参与者数目。int getNumberWaiting()//返回要求启动此 barrier 的参与者数目。int getParties()//查询此屏障是否处于损坏状态。boolean isBroken()//将屏障重置为其初始状态。void reset() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen; &#125;&#125;private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; // 获取“独占锁(lock)” lock.lock(); try &#123; // 保存“当前的generation” final Generation g = generation; // 若“当前generation已损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; // 将“count计数器”-1 int index = --count; // 如果index=0，则意味着“有parties个线程到达barrier”。 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; // 如果barrierCommand不为null，则执行该动作。 final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 唤醒所有等待线程，并更新generation。 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生， // 当前线程才继续执行。 for (;;) &#123; try &#123; // 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。 if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; // 如果等待过程中，线程被中断，则执行下面的函数。 if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; // 如果“当前generation已经损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果“generation已经换代”，则返回index。 if (g != generation) return index; // 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; // 释放“独占锁(lock)” lock.unlock(); &#125;&#125; 到达屏障的线程都执行await()方法,开始阻塞解除阻塞的情况有以下几种1）最后一个线程调用await()2）当前线程被中断3）其他正在该CyclicBarrier上等待的线程被中断4）其他正在该CyclicBarrier上等待的线程超时5）其他某个线程调用该CyclicBarrier的reset()方法]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发之CountDownLatch]]></title>
    <url>%2F2019%2F01%2F09%2Fjava%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch%2F</url>
    <content type="text"><![CDATA[java并发之CountDownLatch 什么是CountDownLatchCountDownLatch是java1.5的时候引入的，同期引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下 作用：使得一个线程或者多个线程等待其他线程工作完成后再执行任务其CountDownLatch是一个闭锁的实现，其闭锁的概念请参考我的另一篇文章——java同步机制https://liuwei110.github.io/2018/12/29/java%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/ CountDownLatch的工作原理CountDownLatch是通过计数器count来实现的，其初始值是线程的数量。每当一个线程完成任务后计数器就会减一，当计数器值为0的时候，则意味着所有线程已经完成任务，则闭锁上的等待线程就可以开始执行任务了 CountDownLatch的源码12345public CountDownLatch(int count); //指定计数的次数，只能被设置1次public void countDown(); //调用此方法则计数减1public void await() throws InterruptedException //调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。Public Long getCount(); //得到当前的计数Public boolean await(long timeout, TimeUnit unit) //调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。 CountDownLatch是依赖AQS来实现的主要关注await()和countDown()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647```**小Demo**countDown()方法建议放置在finally中```javapublic static void main(String[] args) &#123; final CountDownLatch countDownLatch = new CountDownLatch(2); new Thread() &#123; public void run() &#123; try &#123; countDownLatch.await(); System.out.println("子线程"+Thread.currentThread().getName()+"正在执行"); Thread.sleep(1000); System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; try &#123; System.out.println("子线程"+Thread.currentThread().getName()+"正在执行"); Thread.sleep(3000); System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; try &#123; System.out.println("子线程"+Thread.currentThread().getName()+"正在执行"); Thread.sleep(3000); System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125; &#125;.start();&#125; 执行结果：子线程Thread-1正在执行子线程Thread-2正在执行子线程Thread-1执行完毕子线程Thread-2执行完毕子线程Thread-0正在执行子线程Thread-0执行完毕 CountDownLatch的使用场景参考博客：http://www.importnew.com/15731.html（1）开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。 （2）应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 （3）确保一个计算不会执行，直到所需要的资源被初始化。 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。 死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发之ThreadLocal]]></title>
    <url>%2F2019%2F01%2F07%2Fjava%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal%2F</url>
    <content type="text"><![CDATA[java并发之ThreadLocal ThreadLocal概述ThreadLocal，被叫做线程本地变量，为每一个线程提供了变量副本。 ThreadLocal源码解析123456789101112131415161718192021222324252627282930313233public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; private T setInitialValue() &#123; T value = initialValue();//null Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 其中getMap函数及其ThreadLocalMap的初始化：123456ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 从上面的代码可以看出 Thread 类种有个属性是ThreadLocalMap的实例对象，而ThreadLocalMap又是ThreadLocal的内部类 为了自己好记一点：简述set方法：首先获取当前线程实例，然后获取线程实例的属性ThreadLocalMap实例，如果不为空，则map.set(this,value),如果为空则create一个ThreadLocalMap同时添加value; 简述get方法：第一步永远都是获取当前线程实例对象。再获取ThreadLocalMap的实例对象。如果不为空，根据key=this获取Entry,如果Map容器为空，则设置初始值 为什么不直接用线程id来作为ThreadLocalMap的key？ 这一点很容易理解，因为直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？ 而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个ThreadLocal对象都可以由这个对象的名字唯一区分，所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。 ThreadLocal 的作用ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用。作用：提供一个线程内公共变量（比如本次请求的用户信息），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个私有的变量副本，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 更好的了解ThreadLocal举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。 ThreadLocal的使用场景参考一个博客：https://blog.csdn.net/qq_36632687/article/details/79551828最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等123456789private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; public Connection initialValue() &#123; return DriverManager.getConnection(DB_URL); &#125; &#125;; public static Connection getConnection() &#123; return connectionHolder.get(); &#125; 1234567891011121314private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException &#123; Session s = (Session) threadSession.get(); try &#123; if (s == null) &#123; s = getSessionFactory().openSession(); threadSession.set(s); &#125; &#125; catch (HibernateException ex) &#123; throw new InfrastructureException(ex); &#125; return s; &#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java之内存泄漏]]></title>
    <url>%2F2019%2F01%2F02%2Fjava%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[内存泄漏 Memory Leak 什么是内存泄漏？Memory Leak内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。 在Java中内存泄漏的对象符合这两个条件：1.首先这些对象是可达的；2.这些对象是无用的，即后续的程序中并不使用这些对象。这样我们判定为内存泄漏。因为这些对象不无法被GC回收，却又占用着内存。 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏 内存泄漏发生的场景静态集合类像HashMap、Vector等集合类，申明为静态变量时候，由于静态变量的生命周期与应用程序一致，并且他们的所有引用的对象Object都无法释放。1234567Static Vector v = new Vector(10);for (int i = 1; i&lt;100; i++)&#123; Object o = new Object(); v.add(o); o = null;&#125; 循环申请Object 对象，并将所申请的对象放入静态的Vector v 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。 当集合里面的对象属性被修改后，再调用remove()方法时不起作用（前提条件：重写equals()和hashcode()方法）12345678910111213141516171819public static void main(String[] args)&#123; Set&lt;Person&gt; set = new HashSet&lt;Person&gt;(); Person p1 = new Person("唐僧","pwd1",25); Person p2 = new Person("孙悟空","pwd2",26); Person p3 = new Person("猪八戒","pwd3",27); set.add(p1); set.add(p2); set.add(p3); System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 set.remove(p3); //此时remove不掉，造成内存泄漏 set.add(p3); //重新添加，居然添加成功 System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! for (Person person : set) &#123; System.out.println(person); &#125;&#125; 监听器当程序中使用了监听器的时候，如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，而增加了内存泄漏的机会。//todo 各种连接 比如数据库连接、网络连接等，除非显示的使用了close()方法关闭，否则是不会自动被GC回收的。对于Resultset和Statement就会立即为对象可以不进行显式回收，但是对于Connection一定要关闭，因为Connection关闭后其Resultset 和Statement 就会立即为null;但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset、Statement对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。 内部类和外部模块的引用 内部类的引用是比较容易遗忘的一种,而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用,例如程序员A 负责A 模块,调用了B 模块的一个方法如:public void registerMsg(Object b);这种调用就要非常小心了,传入了一个对象,很可能模块B就保持了对该对象的引用,这时候就需要注意模块B 是否提供相应的操作去除引用。 单例模式不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：123456789101112131415161718class A&#123; public A()&#123; B.getInstance().setA(this); &#125;&#125;//B类采用单例模式class B&#123; private A a; private static B instance=new B(); public B()&#123;&#125; public static B getInstance()&#123; return instance; &#125; public void setA(A a)&#123; this.a=a; &#125;//getter...&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java同步机制]]></title>
    <url>%2F2018%2F12%2F29%2Fjava%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[锁的相关概念Synchronized 和 Lock 其锁的概念参照了作者：a2615381来源：CSDN原文：https://blog.csdn.net/a2615381/article/details/79617128 锁的相关概念可重入锁:如果锁具有可冲入性，则他就是可重入锁。即如下面代码，如果一个线程获取锁进入了method1方法，这时候要执行带有synchronized的method2方法，这时候线程不需要申请锁，直接执行method2方法12345678public class Demo&#123; public synchronized void method1()&#123; method2(); &#125; public synchronized void method2()&#123; &#125;&#125; 可中断锁在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 公平锁线程获取锁的顺序是按照申请锁的顺序非公平锁非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 互斥锁互斥锁在Java中的具体实现就是ReentrantLock读写锁读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。自旋锁旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。/////////以下三种锁是指锁的状态，并且是针对Synchronized，来实现高效偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。///////////////闭锁 闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动指导其他活动都完成后才继续执行。CountDownLatch就是一种灵活的闭锁实现。 活锁 LiveLock是一种形式活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。活锁通常发送在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列开头，因此处理器将被反复调用，并返回相同的结果。 无锁 要保证现场安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。 无状态编程。无状态代码有一些共同的特征：不依赖于存储在对上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。 线程本地存储，参考我的另一个博客有关ThreadLocal volatile CAS（Compare And Swap） 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换 Synchronizedjava内置关键字，非公平、可重入锁 Synchronized的使用 Synchronized 同步语句块 1234567891011121314public class Demo&#123; //作用于当前对象实例 public void method()&#123; synchronized(this)&#123; System.out.println("synchronized 同步语句块"); &#125; &#125; public void fun()&#123; //作用于类上 synchronized(Demo.class)&#123; System.out.println("synchronized 同步语句块"); &#125; &#125;&#125; Synchronized 修饰方法 123456public class Demo&#123; //作用于当前对象实例 public synchronized void method()&#123; System.out.println("synchronized 修饰方法"); &#125;&#125; 3.Synchronized 修饰静态方法123456public class Demo&#123; //作用域于当前对象实例 public synchronized static void method()&#123; System.out.println("synchronized 修饰静态方法"); &#125;&#125; Synchronized的缺点一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁释放锁的两种情况：1.线程执行完代码块，自动释放锁2.线程执行发生异常，jvm让线程自动释放锁如果线程无法释放锁，则其他线程只能一直等待下去。 另一种情况就是，如果多线程只是执行读操作，当一个线程获取的读，则其他线程还是需要继续等待下去并且Synchronized无法知道线程有没有成功获取到锁而上面的这些问题Lock均可以办到 Lockjava.util.concurrent.locks包中常用的类和接口。首先是Lock类1234567891011121314151617public interface Lock &#123; void lock();//获取锁，如果锁已被其他线程获取，则进行等待 void lockInterruptibly() throws InterruptedException; /* *获取锁成功返回true;失败返回false,也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 */ boolean tryLock(); /* *这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。 *如果一开始拿到锁或者在等待期间内 */ 拿到了锁，则返回true。 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock();//释放锁 Condition newCondition();&#125; lockInterruptibly()方法比较特殊，如果使用这个方法去获取锁，如果线程正在等待这个锁，则可以中断响应即中断线程的等待状态 ReenterantLockReenterantLock是唯一实现Lock接口的类，并且 ReadWriteLock和ReentrantReadWriteLockReadWriteLock也是一个接口,里面就定义了两个方法123456789101112131415public interface ReadWriteLock &#123; /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock();&#125; ReentrantReadWriteLock实现了ReadWriteLock接口使用读写锁实现多线程读操作123456789101112131415161718192021222324252627282930313233public class ReadWriteDemo &#123; ReentrantReadWriteLock rwlLock = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final ReadWriteDemo testDemo = new ReadWriteDemo(); new Thread() &#123; public void run() &#123; testDemo.read(Thread.currentThread()); &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; testDemo.read(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void read(Thread thread) &#123; rwlLock.readLock().lock(); try &#123; for(int i=0;i&lt;10;i++) &#123; Thread.sleep(1000); System.out.println(thread.getName()+"正在读。。。。。。"); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+"读操作完毕"); rwlLock.readLock().unlock(); &#125; &#125;&#125; Synchronized和Lock对比Synchronized是一个内置关键字，而Lock是一个接口Synchronized是非公平可重入锁，Lock（ReentrantLock）默认是非公平可重入锁，但是可以定位为公平锁Synchronized不需要手动去加锁释放锁，而Lock需要Synchronized不可以让等待锁的线程响应中断，而Lock可以通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。Lock可以提高多个线程进行读操作的效率。 总结：在竞争不太激烈的时候两者性能差不多，而竞争十分激烈的时候，则Lock的性能大于synchronized volatilejava 提供了一个稍弱的同步机制——volatile,用来确保将变量的更新通知到其他线程。将变量申明为volatile类型。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 == 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 ==当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 volatile具备的特性1.可见性 2.禁止指令重排：有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量]]></content>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java锁之AQS]]></title>
    <url>%2F2018%2F12%2F29%2Fjava%E9%94%81%E4%B9%8BAQS%2F</url>
    <content type="text"><![CDATA[谈到ReentrantLock不得不谈AQS(队列同步器AbstractQueueSynchronizer) 结合ReentrantLock分析参考博客来源：CSDN网址:https://www.cnblogs.com/waterystone/p/4920797.html网址：https://www.cnblogs.com/java-zhao/p/5131544.html AQS其ReenterantLock的实现需要提到其内部类Sync的父类说起，也就是AbstractQueuedSynchronizer（AQS）。AQS是一个基于FIFO等待队列实现的用于实现一个同步器框架的基础的框架AQS的核心思想是基于volatile int state这样的一个属性同时配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。当state的值为0的时候，标识改Lock不被任何线程所占有。 框架 源码分析先看看ReentrantLock的源码只贴了主要代码123456789101112131415161718192021222324252627282930public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync;//同步器：内部类Sync的一个引用 //从下面的主要函数可以看出ReentrantLock的实现依赖于Sync public ReentrantLock() &#123;//默认是非公平锁 sync = new NonfairSync(); &#125; public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; public void lock() &#123; sync.lock(); &#125; public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; public void unlock() &#123; sync.release(1); &#125; AQS的源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; //锁数量 private volatile int state; //获取锁的方法lock的语义 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();//中断自己 &#125; //此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义 //????为啥直接抛出异常？？AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现 protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; private Node addWaiter(Node mode) &#123; //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享） Node node = new Node(Thread.currentThread(), mode); //尝试快速方式直接放到队尾。 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //上一步失败则通过enq入队。 enq(node); return node; &#125; //此方法用于加入队列尾部 private Node enq(final Node node) &#123; //CAS"自旋"，直到成功加入队尾 for (;;) &#123; Node t = tail; if (t == null) &#123; // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123;//正常流程，放入队尾 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; /*通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。该线程下一部该干什么了？进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键。 */ final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true;//标记是否成功拿到资源 try &#123; boolean interrupted = false;//标记等待过程中是否被中断过 //又是一个“自旋”！ for (;;) &#123; final Node p = node.predecessor();//拿到前驱 //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。 p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！ failed = false; return interrupted;//返回等待过程中是否被中断过 &#125; //如果自己可以休息了，就进入waiting状态，直到被unpark() if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;&#125; AQS中Node的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//同步等待队列（双向链表）中的节点 static final class Node &#123; /** 线程被取消了 */ static final int CANCELLED = 1; /** * 如果前驱节点的等待状态是SIGNAL，表示当前节点将来可以被唤醒，那么当前节点就可以安全的挂起了 * 否则，当前节点不能挂起 */ static final int SIGNAL = -1; /**线程正在等待条件*/ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** 一个标记：用于表明该节点正在独占锁模式下进行等待 */ static final Node EXCLUSIVE = null; //值就是前四个int（CANCELLED/SIGNAL/CONDITION/PROPAGATE），再加一个0 volatile int waitStatus; /**前驱节点*/ volatile Node prev; /**后继节点*/ volatile Node next; /**节点中的线程*/ volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * 返回该节点前一个节点 */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // 用于addWaiter中 this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>随笔</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之线程池]]></title>
    <url>%2F2018%2F12%2F27%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[java基础之线程池 线程池的核心参数123456789public ThreadPoolExecutor( int corePoolSize, //核心池的大小。 int maximumPoolSize, //池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量 long keepAliveTime, //当线程数大于corePoolSize时，终止前多余的空闲线程等待新任务的最长时间 TimeUnit unit, //keepAliveTime时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //存储还没来得及执行的任务 ThreadFactory threadFactory, //执行程序创建新线程时使用的工厂 RejectedExecutionHandler handler //由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序) 1.corePoolSize2.maximumPoolSize3.keepAliveTime4.unit5.workQueue6.threadFactory7.handler 线程池的实现过程池中线程数量小于corePoolSize的时候，新任务不用排队直接添加新线程当池中线程数量大于corePoolSize的时候且workQueue队列未满，则将任务加入到workQueue中当池中线程数量大于corePoolSize的时候且workQueue队列已满，且线程池数量小于maximumPoolSize，添加新的线程池来处理任务当线程池的数量大于corePoolSize的时候且workQueue队列已满，且线程池数量大于maximumPoolSize，则执行拒绝策略 常见的线程池最顶部的接口是java.util.concurrent里的Executor接口。 newSingleThreadPool ( ) 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; newFixedThreadPool ( )为什么这里corePoolsize和maximumpoolsize是相同的？这是因为他的队列是无界的，当队列是无界的时候maximumpoolsize是没有意义的。keepAliveTime和unit的设值表名什么？——该实现不想keep alive！123456789public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newCachedThreadPool( )看函数，这个首先呢线程池是无界的了。其次呢这里在队列的选择上使用了synchronousQueue，这意味着每个插入操作必须等待另一个线程的移除操作。12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; newScheduledThreadPool创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。 线程池排队的策略排队有三种通用策略直接提交SynchronousQueue无界队列LinkedBlockingQueue有界队列ArrayBlockingQueue 线程池的拒绝策略RejectedExecutionHandler换个方法来说。就是老板就算借了工人过来但是任务还是一直来人手又不够了，但是已经没办法继续借工人了。这个时候呢就要考虑拒绝任务了 策略1：CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度就这个策略来说并不想放弃执行任务，然后就让executor本身来执行任务 123456789public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125; 策略2：abortPolicy:处理程序遭到拒绝将抛出运行RejectedExecutionException也就是丢弃任务，并且抛出一个异常 12345public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(); &#125; 策略3：discardPolicy:不能处理的任务将直接被删除这个策略和策略2一样也是丢弃任务，但是并不抛出异常 123public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125; 策略4：discardOldestPolicy:如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程） 1234567891011public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之进阶之路]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[索引、存储引擎 索引的种类普通索引：仅加速查询 唯一索引：加速查询 + 列值唯一（可以有null） 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引：对文本的内容进行分词，进行搜索 ps：索引合并，使用多个单列索引组合搜索覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖 索引的类型1.B+树索引是大多数 MySQL 存储引擎的默认索引类型。B+树的原理B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。与B树的区别B树的每个节点都存储数据上，而B+树只有叶子节点存储了数据B+树的叶子节点有指针相连，方便区间查询 操作进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。 与红黑树的比较 红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： （一）更少的查找次数 平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logd N)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。 (二）利用磁盘预读特性(///???//todo) 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。———————————————分界线————————————————-因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 2.哈希索引哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找。InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 3.全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 4.空间索引MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 存储引擎InnoDB是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 两者比较事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。(如果在应用中执行大量insert和update操作，可选择。) 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。 全文索引:MyISAM支持全文类型索引，而InnoDB不支持全文索引 性能:MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM 封锁封锁粒度MYSQL中提供了两种封锁粒度：表级锁和行级锁 封锁类型读写锁排它锁（Exclusive），简写为 X 锁，又称写锁。共享锁（Shared），简写为 S 锁，又称读锁。 只有当都是共享锁的时候才兼容 意向锁意向锁在原来的X/S锁的基础上引入了IX/IS锁。IX/IS都是属于表锁用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 各种锁的兼容： | - | X | IX | S | IS || X | - | - | - | - || IX | - | √ | - | √ || S | - | - | √ | √ || IS | - | √ | √ | √ | 要领：任意的IS/IX之间是兼容的，它们只能表达想加锁的意向，并不是真正的加锁；S锁之和IS、S锁兼容 封锁协议三级封锁协议一级封锁协议事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之优化]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库优化 表结构优化sql优化explain使用explain关键字来分析select查询语句比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 慢查询日志MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，MySQLl数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。 查询慢日志参数：1show variables like 'slow_query%'; 修改当前配置:1set global 变量名 = 值; 优化数据访问 减少请求的数据量只返回必要的列：最好不要使用 SELECT * 语句。只返回必要的行：使用 LIMIT 语句来限制返回的数据。缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 减少服务器端扫描的行数最有效的方式是使用索引来覆盖查询。 重构查询方式 切分大查询一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);rows_affected = 0do { rows_affected = do_query( “DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000”)} while rows_affected &gt; 0 分解大连接查询将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。减少锁竞争；在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 索引优化最左前缀匹配原则，对 where,on,group by,order by 中出现的列使用索引索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);为较长的字符串使用前缀索引对于like查询，”%”不要放在前面。 分区分表读写分离]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之基础]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库事务 1.事务事务就是指满足ACID的一系列操作，可以使用 commit提交一个事务，也可以使用rollback回滚 2.数据库事务的四个特性ACID原子性：事务的最小单位，不允许再被分割。意味着执行的话要么一起成功，要么一起失败。如果事务在执行的过程中发生错误，则回滚到事务执行前最初状态一致性：数据库在事务执行前后是保持一致的隔离性：一个事务在做出修改时在被提交之前对其他事务是不可见的持久性：一旦事务提交以后，做出的修改就被永久的保存在数据库中，并不会被回滚 3.事务的隔离级别在讲事务隔离级别之前必须先看看为什么会出现隔离级别这种概念上面讲到了事务必须是满足ACID四个特性的在并发的情况下，事务的隔离性很难满足，因此会发生一系列并发一致性问题参考文章-讲的超级好COPY 并发导致的问题丢失修改当T1和T2修改同一个数据的时候，T1先执行，T2后执行，当T1执行var=50以后，T2又执行var=100，将T1的执行结果覆盖。 脏读当T1对数据进行修改后，这个时候T2读取了T1修改后的数据，但随后T1又执行了回滚操作，那么这个时候T2读出来的就是脏数据 不可重复读（在一个事务范围内操作读取两次同一数据获取的内容不一样）T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。幻影读T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 不可重复读和幻影读不可重复读重点在update，而幻影读重点在于insert和delete 说完并发情况下可能出现的问题后，再讲解下事务的隔离级别 ==隔离级别==Read Uncommitted 未提交读事务中的修改哪怕没有提交对其他事务也是可见的。最低的隔离级别，可能会导致脏读、不可重复读、幻影读Read Committed 提交读允许读取并发事务已经提交的数据可以阻止脏读、但是幻读和不可重复读还是有可能发生Repeatable Read 可重复读保证在同一个事务中多次读取同样数据的结果是一样的。可以阻止脏读和不可重复读，幻读可能会发生Serializable 可串行化最高隔离级别，让各个事务都逐个执行，完全遵循acid的隔离级别。该级别可以防止脏读、不可重复读以及幻读。但是严重的影响了程序的性能 ==MYSQL默认采用REPEATABLE_READ级别，ORACLE默认采用READ_COMMITTED隔离级别==]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之消费者模式]]></title>
    <url>%2F2018%2F12%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring面试汇总]]></title>
    <url>%2F2018%2F12%2F10%2FSpring%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Spring面试汇总 参考博客：https://blog.csdn.net/a745233700/article/details/80959716 什么是Spring?Spring是为了解决企业开发复杂性的一种轻量级框架，其有两大核心的基本特征：IOC和AOPIOC:控制反转，还有另一种说法叫做DI(依赖注入)，这是一种设计思想。IOC就是根据你的需求去拿你需要的对象给你,利用java反射原理来创建对象，不需要自己手动去new一个。 IOC的三种注入方式：1.构造器注入2.set注入（如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。）3。注解注入 AOP：就是面向切面编程，在对程序不修改的情况下，对程序进行动态的扩展。可用于权限的认证、日志、事务的处理。spring aop主要利用动态代理——jdk动态代理和CGlib动态代理。其两者的不同在于jdk动态代理要求被代理的类必须实现一个接口（可以看代理模式那个笔记）。 以下为摘抄： ①JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法，当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。 ②如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。作者：a745233700来源：CSDN原文：https://blog.csdn.net/a745233700/article/details/80959716 Spring中几种bean的作用域1.singleton:这种是默认的，相当于单例模式；即不管接收到多少种请求，只有一个bean实例，由bean factory自身来维护的2.prototype:每次请求提供一个实例相当于new3.request:每一个来自客户端请求创建一个实例，请求完成后，就失效被gc回收4.session:每个session中有一个bean的实例，在session过期后，bean会随之失效。5,global-session:global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。 bean的生命周期1.实例化bean2.根据spring上下文对实例化bean进行配置——IOC注入 3.如果这个bean实现了BeanNameAware接口，则调用它的setBeanName方法，此方法传递的是bean的id4.如果这个bean实现了BeanFactoryAware接口，则调用它的setBeanFactory方法传递的是spring工厂自身5.如果这个bean实现了ApplicationContextAware接口，则调用它的setAppplicationContext方法，传入spring上下文6.如果这个bean实现了其他…Aware接口，则调用它的相关方法 7.如果这个bean关联了BeanPostProcessor接口，调用postProessBeforeInitialization方法（经常被用作bean内容的修改）8.如果bean在spring配置文件中配置了init-method属性，则调用其初始化方法9.如果这个bean关联了BeanPostProcessor接口，调用postProessAfterInitialization方法 10.当bean不再被需要进入清理阶段，如果bean实现了DisposableBean接口，则调用destory方法11.如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。 spring中的自动装配（1）no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。 （2）byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 （3）byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 （4）constructor：构造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 （5）autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。]]></content>
      <tags>
        <tag>面试</tag>
        <tag>随笔</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构之SpringCloud]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B9%8BSpringCloud%2F</url>
    <content type="text"><![CDATA[微服务架构之SpringCloud SpringCloud概述SpringCloud是基于SpringBoot的一整套实现微服务的框架，提供了配置管理、服务的发现、断路器、智能路由，微代理，控制总线，一次性令牌，全局锁，主节点选举， 分布式session, 集群状态等公共组件。 SpringCloud的使用下面分别讲解SpringCloud分布式开发的五大核心服务发现——Eureka负载均衡——Ribbon断路由——Hystrix声明式服务调用——Feign服务网关——Zuul分布式配置——SpringCloud Config EurekaEureka,一个REST服务，主要分为服务器和客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化跟服务器的交互，作为轮询负载均衡器，并提供服务的故障切换支持 Eureka服务器：导入相关的依赖1234567891011121314151617181920&lt;dependency&gt; &lt;!--Eureka服务的依赖--&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 配置文件：123456server: port: 6868eureka: client: register-with-eureka: false #是否将自己注册在注册中心中 fetch-registry: false #是否从注册中心中获取信息 在启动类上添加启动Eureka服务器的注释123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 其Eureka客户端只需将配置文件中改成(通常根据name寻找服务)12345678910spring: application: name: university-usereureka: client: register-with-eureka: true #是否将自己注册在注册中心中 fetch-registry: true #是否从注册中心中获取信息 service-url: defaultZone: http://localhost:6868/eureka/ 启动类上的注释变为@EnableEurekaClient或者使用通用注解@EnableDiscoveryClient（即使使用其他服务注册组件也可以通用） Ribbon主要提供负载均衡算法，其主要的一些负载均衡算法有：（默认是轮询）1.简单轮询负载均衡2.加权响应时间负载均衡3.区域感知轮询负载均衡4.随机负载均衡 Ribbon的使用：1.添加Ribbon依赖2.RestTemplate添加注解@LoadBalanced Hystrix在微服务架构中存在着很多个单元，如果其中一个单元出现问题，则会由于依赖关系导致整个系统的瘫痪；断路器就是为了解决这一问题。 Hystrix通过一下方式解决依赖隔离：包裹请求：使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中执行跳闸机制：当某服务的错误率超过一定的阈值时，Hystrix可以手动/自动的跳闸，停止请求该服务一段时间资源隔离：Hystrix为每个依赖都维护一个小型线程池，如果线程池满了，则会拒绝请求，而不是排队等候监控：实时依赖的统计和监控，例如:成功，失败（抛出异常），超时，线程拒绝回退机制：当请求成功，失败（抛出异常），超时，线程拒绝或者断路器打开的时候执行回退逻辑，一般回退逻辑内容开发人员自己编写 Hystrix的使用1.导入Hystrix的相关依赖2.在启动类上添加注解@EnableHystrix3.在调用微服务提供的接口函数上添加注解如：@HystrixCommand(fallbackMethod=”回退函数名”)//回退函数返回值要一致 FeignDubbo和SpringCloud区别：Dubbo的调用方式是RPC，而SpringCloud调用方式是Rest API]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>微服务</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常]]></title>
    <url>%2F2018%2F11%2F28%2Fjava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[java异常体系 java异常体系在Java中将异常作为一个类，当作对象来处理。所有的异常的基类是——Throwable类，其下有两大子类Error,Exception。这三种异常通常可以分为三大类：系统错误、非运行时异常和运行时异常。 Error系统错误是由java虚拟机抛出的，Error类描述的是内部系统错误，如java虚拟机崩溃，一般程序自身无法处理。如OutOfMemoryError、ThreadDeath等 ExceptionException分为运行时异常和非运行时异常 运行时异常运行时异常如NullPointerException、IndexOutOfBoundsException等,这些异常是不检查异常,程序中可以选择捕获处理,也可以不处理。这些异常一般是由程序逻辑错误引起的,程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常非运行时异常是RuntimeException以外的异常,类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常,如果不处理,程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常,一般情况下不自定义检查异常。]]></content>
      <tags>
        <tag>java</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常之OOM]]></title>
    <url>%2F2018%2F11%2F28%2Fjava%E5%BC%82%E5%B8%B8%E4%B9%8BOOM%2F</url>
    <content type="text"><![CDATA[OOM(out of memory)由于遇到的较少….目前只能写个概念…未完待续…. 什么是OOM?OOM即out of memory 翻译过来就是“内存用完了”，来源于java.lang.OutOfMemeoryError;官方说明：Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。 为什么会产生OOM1.分配的太少了，不够用比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。2.应用用的太多，且用完没有释放资源，浪费了。此时就会造成内存泄露或者内存溢出 常见的OOM情况1.java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。 2.java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。 3.java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。]]></content>
      <tags>
        <tag>java</tag>
        <tag>Exception</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2018%2F11%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式-代理模式]]></content>
      <tags>
        <tag>java</tag>
        <tag>随笔</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础之集合-map]]></title>
    <url>%2F2018%2F11%2F21%2Fjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88-map%2F</url>
    <content type="text"><![CDATA[map集合HashMap-TreeMap-LinkedHashMap-ConcurrentHashMap-WeakHashMap HashMapHashMap主要用于存储键值对，基于哈希表Map来实现的HashMap的初始化大小是16，每次扩容为原来的两倍 底层数据结构分析JDK1.8之前采用的数组+链表的方式来实现的；put()：HashMap通过key的hashcode经过扰动函数处理后，通过（n-1）&amp; h （其中n表示数组的长度）来判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。并且其put方法采用的是头插法ps：所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。12345678910111213141516171819202122public V put(K key, V value) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 再插入 return null;&#125; JDK1.8当链表的长度大于阈值（默认为8），链表会转变成红黑树，以减少查询的时间并且简化了扰动函数其put方法采用的尾插法put():1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125; 解决Hash冲突的方法开发定值法拉链法（链地址法）建立公共溢出区HashMap和HashTable1.HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常2.HashTable是线程安全的，HashMap是线程不安全的，因为HashTable的公开方法使用了synchronized修饰 TreeMapTreeMap 是一个有序的key-value集合，它是通过红黑树实现的。根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。TreeMap是非同步的。 红黑树的特性（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 LinkedHashMap继承于HashMap,可以认为是HashMap+LinkedList,使用LinkedList来维护插入元素的先后次序LinkedHashMap中Key和Value都允许空LinkedHashMap是有序的（默认都采用插入顺序来维持取出键值对的次序）LinkedHashMap非线程安全LinkedHashMap的属性：1234567891011/** * The head of the doubly linked list. * 双向链表的头节点 */private transient Entry&lt;K,V&gt; header;/** * The iteration ordering method for this linked hash map: true * for access-order, false for insertion-order. * true表示最近最少使用次序，false表示插入顺序 */private final boolean accessOrder; LinkedHashMap如何保证顺序？在Entry中添加了Entry&lt;K, V&gt; before和Entry&lt;K, V&gt; after两个属性（一定要分清除next和before、after；next是用于维护HashMap指定table位置上连接的Entry的顺序的，before、After是用于维护Entry插入的先后顺序的） 利用LinkedHashMap来实现LRU即Least Recently Used缓存 ConcurrentHashMapWeakHashMap]]></content>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序]]></title>
    <url>%2F2018%2F11%2F18%2F%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法 算法-排序排序算法的时间复杂度和空间复杂度​​​​​​​​ 冒泡排序首先看看最原始的冒泡排序的实现如下图所示 代码实现：12345678910111213141516171819public void sort (int [] array)&#123; if(array==null||array.length&lt;2)&#123; return; &#125; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array.length-i-1;j++)&#123; //前面数据大于后面数据则则进行调换 if(array[j]&gt;array[j+1])&#123; array[j+1]=temp; array[j+1]=array[j]; array[j]=temp; &#125; &#125; &#125;&#125; 优化思路如果排序的数组是这样的1，2，3，4，9，8，7；对于这种前半部分根本不需要排序，后半部分才需要排序的，我们是可以更加优化的 代码实现：12345678910111213141516171819202122public void sort(int []array)&#123; if(array==null||array.length&lt;2) return; //这里使用一个标志变量 boolean flag=true; int x=0; int temp=0; while(flag)&#123; flag=false; for(int i=0;int i&lt;array.length-1-x;i++)&#123; if(array[i]&gt;array[i+1])&#123; array[i]=temp; array[i]=array[i+1]; array[i+1]=temp; flage=true;//一旦进行交换了就再次进入循环 &#125; &#125; x++; &#125;&#125; 其实还可以更加优化，比如缩小边界；如果 是543216789，后面是排好序的，则只需要记录到最后一次交换的那个位置就行了12345678910111213141516171819202122public void sort(int []array)&#123; if(array==null||array.length&lt;2) return; int temp=0; int flag=array.length-1; int x=array.length-1; while(flag&gt;0) &#123; x=-1; for(int j=0;j&lt;=flag-1;j++)&#123; if(array[j]&gt;array[j+1])&#123; temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; x=j; &#125; &#125; flag=x; &#125;&#125; 选择排序动态图演示 代码实现：123456789101112131415161718192021222324void SelectSort_1(int vec[], int n) //选择排序基础算法 &#123; int i, j, min; int temp; for (i=0; i&lt;n-1; i++) &#123; min = i; for (j=i+1; j&lt;n; j++) &#123; if (vec[j] &lt; vec[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; temp = vec[i]; vec[i] = vec[min]; vec[min] = temp; &#125; &#125;&#125; 优化思路优化的思路，在选择最小值的同时也选择最大值，不断的缩小范围。 优化后的选择排序：12345678910111213141516171819202122232425262728293031323334private static void sort(int[] array) &#123; // TODO Auto-generated method stub if (array==null||array.length&lt;2) &#123; return; &#125; int minIndex=0; int maxIndex=0; int j=array.length-1; int temp1=0; for (int i = 0; i &lt; array.length; i++) &#123; if(i&gt;j) &#123; break; &#125; minIndex=i; maxIndex=i; for (int k = i+1; k &lt; array.length-i; k++) &#123; if (array[k]&lt;array[minIndex]) &#123; minIndex=k; &#125; if (array[k]&gt;array[maxIndex]) &#123; maxIndex=k; &#125; &#125; temp1=array[i]; array[i]=array[minIndex]; array[minIndex]=temp1; temp1=array[j]; array[j]=array[maxIndex]; array[maxIndex]=temp1; j--; &#125; &#125; 插入排序代码实现：123456789101112131415161718private static void sort(int[] array) &#123; // TODO Auto-generated method stub int index=0; int temp=0; for (int i = 0; i &lt; array.length-1; i++) &#123; index=i+1; temp=array[index]; for (int j = i; j &gt;=0; j--) &#123; if (temp&lt;array[j]) &#123; array[index]=array[j]; index--; &#125;else &#123; break; &#125; &#125; array[index]=temp; &#125; &#125; 优化思路在查找要插入的位置的时候使用二分法查找12 希尔排序 代码实现：1234567891011121314private static void sort(int[] num) &#123; int temp=0; int tag = num.length/2;//间隔 for (int i=tag;i&gt;0; i--) &#123; for (int j= 0; j+i &lt; num.length; j++) &#123; if (num[j]&gt;num[j+i]) &#123; temp = num[j]; num[j]=num[j+i]; num[j+i]=temp; &#125; &#125; &#125; &#125; 归并排序代码实现 1234567891011121314151617181920212223242526272829303132333435private static void sort(int[] nums,int start, int end) &#123; if (start&gt;=end) &#123; return ; &#125; int index = (start+end)/2; sort(nums, start, index); sort(nums, index+1, end); merg(nums,start,index,end); &#125; private static void merg(int[] nums, int l, int m, int h) &#123; // TODO Auto-generated method stub int aux[]=new int[h+1]; int i = l, j = m + 1; for (int k = l; k &lt;= h; k++) &#123; aux[k] = nums[k]; // 将数据复制到辅助数组 &#125; for (int k = l; k &lt;= h; k++) &#123; if (i &gt; m) &#123; nums[k] = aux[j++]; &#125; else if (j &gt; h) &#123; nums[k] = aux[i++]; &#125; else if (Math.min( aux[i],nums[j])==aux[i]) &#123; nums[k] = aux[i++]; // 先进行这一步，保证稳定性 &#125; else &#123; nums[k] = aux[j++]; &#125; &#125; &#125; 快速排序 代码实现12345678910111213141516171819202122232425262728293031323334353637private static void sort(int[] nums,int left ,int right) &#123; int base = nums[left]; int i=left; int j=right; if (left&gt;=right) &#123; return; &#125; boolean flag=true; while (true) &#123; if (left&gt;=right) &#123; nums[left]=base; break; &#125; if(flag)&#123; if (nums[right]&lt;base) &#123; nums[left]=nums[right]; flag=false; &#125;else &#123; right--; &#125; &#125; if(!flag)&#123; if (nums[left]&gt;base) &#123; nums[right]=nums[left]; flag=true; &#125;else &#123; left++; &#125; &#125; &#125; sort(nums,i,left-1); sort(nums,left+1,j); &#125; 堆排序堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 12]]></content>
      <tags>
        <tag>java</tag>
        <tag>随笔</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机深入解析]]></title>
    <url>%2F2018%2F11%2F17%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CSDN传送~ jvm的内存模型1. 程序计数器线程私有。作用：可以看作是当前线程所执行的字节码文件的行号指示器。像分支、循环、跳转、异常处理等功能都需要依赖这个计数器完成 2. Jvm虚拟机栈线程私有。作用：虚拟机栈描述的是java方法的内存模型：每个方法被执行的时候会创建个栈帧，用于存放局部变量表、方法出口等信息。（局部变量表放的是基本数据类型、对象引用和returnAddress类型（指向一条字节码指令地址））。 3. 本地方法栈线程私有。作用：与java虚拟机栈相似，只是为本地方法服务而已。 4. java堆线程共享。作用：是java虚拟机管理内存最大的一块，用于存放对象实例，几乎所有的对象实例都在这里分配内存。 5. 方法区线程共享。作用：用于存储被虚拟机加载的类信息、常量、静态变量等数据。 GC垃圾回收判断对象是否需要被回收 如何判断一个对象是否需要被回收（“死亡”）？可达性分析法：通过GC Roots作为起点进行搜索，可以到达的对象是存活的，不可以到达的对象则是“死亡的”，需要被回收的。Java中可以作为GC Roots的对象：1.Jvm虚拟机栈中局部变量表中的引用的对象2.本地方法中的JNI(java native interface)中引用的对象3.方法区中常量引用的对象4.方法区中静态属性引用的对象 垃圾回收算法1.标记-清除算法标记要回收的对象，然后清除不足：标记和清除的效率不高；产生大量不连续的内存碎片，导致无法给大对象分配内存。 2.复制算法复制算法的提出是为了克服句柄的开销和解决内存碎片问题。将内存分成两块大小一样的区域，每次只使用一半的内存，当内存使用完的时候，就将还存活的对象复制到另一半内存中，然后将用过的那一半内存清理掉。不足：只使用了一半的内存。 3.标记-整理算法在标记-清除的基础上，在清除的时候，将存活的对象向左端空闲的地方移动。不足：开销比较大，但是解决了内存碎片问题 4.分代算法核心思想是根据对象的存活周期将内存分为不同的区域。一般堆区分为年轻代和年老代，在堆区之外还有一个永久代。年轻代每次都有量的对象需要被回收，年老代每次只有少量的对象需要回收；然后再根据不同的代的特点使用不同的回收算法。 年轻代的回收算法1.将新生的对象都放在年轻代中2.年轻代的内存按照8:1:1分成Eden区和两个Suvivor（suvivor0,suvivor1）区,大部分的对象都在Eden区生成。回收的时候先将Eden区存活的对象放置在suvivor0区，然后再将Eden区清空。当suvivor0区存放满了的时候，则将Eden区和suvivor0区存活的对象放置在suvivor1区中，然后将其他两个区清空。此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。3.当survivor1空间满了的时候，此时将存活的对象直接放入年老代，如果年老代也满了则会触发一次Full GC,也就是年轻代和年老代都发生垃圾回收4.年轻代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。 年老代的回收算法1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 永久代的回收算法用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。 垃圾收集器1.Serial收集器年轻代使用复制算法，年老代使用标记-整理算法Serial收集器是一个单线程的垃圾收集器，当进行回收时会暂停所有其他工作线程，进行垃圾回收。（Client模式下的虚拟机中首选新生代收集器）优点：（与其他单线程垃圾收集器相比）简单高效缺点：停顿时间较长2.ParNew收集器年轻代使用复制算法，年老代使用标记-整理算法ParNew收集器就是Serial收集器的多线程版本，在进行垃圾回收的时候也会暂停其他所有的工作线程。（Server模式下的虚拟机中首选新生代收集器）CMS收集器虚拟机第一款真正意义上工作线程和回收线程并发的收集器，停顿时间短，注重用户体验。标记-清除算法实现的垃圾收集器。运作相对前面收集器更加复杂，整个过程分成4部分：1.初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；2.并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。3.重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短4.并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。 缺点：对CPU资源敏感；无法处理浮动垃圾；它使用的“标记-清除”算法会导致收集结束时会有大量空间碎片产生优点：并发收集、停顿时间短，用户体验好 G1收集器G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.G1收集器大致分为以下几个步骤：1.初始标记2.并发标记3.最终标记4.筛选回收优点：1.并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。2.分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。3.空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。4.可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内 垃圾收集会被触发条件（1）程序调用System.gc时可以触发；（2）系统自身来决定GC触发的时机。Minor GC ，Full GC 触发条件Minor GC触发条件： 当Eden区满时，触发Minor GC。Full GC触发条件：（1）调用System.gc时，系统建议执行Full GC，但是不必然执行（2）老年代空间不足（3）方法区空间不足（4）上一次GC之后Heap的各域分配策略动态变化；]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
